import { signature, publicKey, ciphertext, privateKey, authn, keystore, conversationReference, messageApi, invitation, content, message } from '@xmtp/proto';
import { NotifyStreamEntityArrival } from '@xmtp/proto/ts/dist/types/fetch.pb';
import Long from 'long';
import { Envelope } from '@xmtp/proto/ts/dist/types/message_api/v1/message_api.pb';

interface Signer {
    getAddress(): Promise<string>;
    signMessage(message: ArrayLike<number> | string): Promise<string>;
}

declare type ECDSACompactWithRecovery = {
    bytes: Uint8Array;
    recovery: number;
};
declare class Signature implements signature.Signature {
    ecdsaCompact: ECDSACompactWithRecovery | undefined;
    walletEcdsaCompact: ECDSACompactWithRecovery | undefined;
    constructor(obj: Partial<signature.Signature>);
    signerKey(key: SignedPublicKey): Promise<UnsignedPublicKey | undefined>;
    getPublicKey(digest: Uint8Array): PublicKey | undefined;
    equals(other: Signature): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): Signature;
}
interface KeySigner {
    signKey(key: UnsignedPublicKey): Promise<SignedPublicKey>;
}

declare type secp256k1Uncompressed = {
    bytes: Uint8Array;
};
declare class UnsignedPublicKey implements publicKey.UnsignedPublicKey {
    createdNs: Long;
    secp256k1Uncompressed: secp256k1Uncompressed;
    constructor(obj: publicKey.UnsignedPublicKey);
    generated(): Date | undefined;
    isFromLegacyKey(): boolean;
    get timestamp(): Long;
    verify(signature: Signature, digest: Uint8Array): boolean;
    verifyKey(pub: PublicKey | SignedPublicKey): Promise<boolean>;
    equals(other: this): boolean;
    getEthereumAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): UnsignedPublicKey;
}
declare class SignedPublicKey extends UnsignedPublicKey implements publicKey.SignedPublicKey {
    keyBytes: Uint8Array;
    signature: Signature;
    constructor(obj: publicKey.SignedPublicKey);
    get unsignedKey(): UnsignedPublicKey;
    signerKey(): Promise<UnsignedPublicKey | undefined>;
    walletSignatureAddress(): Promise<string>;
    equals(other: this): boolean;
    bytesToSign(): Uint8Array;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SignedPublicKey;
    toLegacyKey(): PublicKey;
    static fromLegacyKey(legacyKey: PublicKey, signedByWallet?: boolean): SignedPublicKey;
}
declare class PublicKey extends UnsignedPublicKey implements publicKey.PublicKey {
    signature?: Signature;
    constructor(obj: publicKey.PublicKey);
    get timestamp(): Long;
    bytesToSign(): Uint8Array;
    signWithWallet(wallet: Signer): Promise<void>;
    walletSignatureAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PublicKey;
}

declare class SignedPublicKeyBundle implements publicKey.SignedPublicKeyBundle {
    identityKey: SignedPublicKey;
    preKey: SignedPublicKey;
    constructor(bundle: publicKey.SignedPublicKeyBundle);
    walletSignatureAddress(): Promise<string>;
    equals(other: this): boolean;
    toBytes(): Uint8Array;
    isFromLegacyBundle(): boolean;
    toLegacyBundle(): PublicKeyBundle;
    static fromBytes(bytes: Uint8Array): SignedPublicKeyBundle;
    static fromLegacyBundle(bundle: PublicKeyBundle): SignedPublicKeyBundle;
}
declare class PublicKeyBundle implements publicKey.PublicKeyBundle {
    identityKey: PublicKey;
    preKey: PublicKey;
    constructor(bundle: publicKey.PublicKeyBundle);
    equals(other: this): boolean;
    walletSignatureAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PublicKeyBundle;
}

declare class Ciphertext implements ciphertext.Ciphertext {
    aes256GcmHkdfSha256: ciphertext.Ciphertext_Aes256gcmHkdfsha256 | undefined;
    constructor(obj: ciphertext.Ciphertext);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): Ciphertext;
}

declare type secp256k1 = {
    bytes: Uint8Array;
};
declare class SignedPrivateKey implements privateKey.SignedPrivateKey, KeySigner {
    createdNs: Long;
    secp256k1: secp256k1;
    publicKey: SignedPublicKey;
    constructor(obj: privateKey.SignedPrivateKey);
    static generate(signer: KeySigner): Promise<SignedPrivateKey>;
    generated(): Date | undefined;
    sign(digest: Uint8Array): Promise<Signature>;
    signKey(pub: UnsignedPublicKey): Promise<SignedPublicKey>;
    static signerKey(key: SignedPublicKey, signature: ECDSACompactWithRecovery): Promise<UnsignedPublicKey | undefined>;
    sharedSecret(peer: SignedPublicKey | UnsignedPublicKey): Uint8Array;
    encrypt(plain: Uint8Array, peer: UnsignedPublicKey, additionalData?: Uint8Array): Promise<Ciphertext>;
    decrypt(encrypted: Ciphertext, peer: UnsignedPublicKey, additionalData?: Uint8Array): Promise<Uint8Array>;
    matches(key: SignedPublicKey): boolean;
    equals(other: this): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SignedPrivateKey;
    static fromLegacyKey(key: PrivateKey, signedByWallet?: boolean): SignedPrivateKey;
}
declare class PrivateKey implements privateKey.PrivateKey {
    timestamp: Long;
    secp256k1: secp256k1;
    publicKey: PublicKey;
    constructor(obj: privateKey.PrivateKey);
    static generate(): PrivateKey;
    generated(): Date | undefined;
    sign(digest: Uint8Array): Promise<Signature>;
    signKey(pub: PublicKey): Promise<PublicKey>;
    sharedSecret(peer: PublicKey | SignedPublicKey): Uint8Array;
    encrypt(plain: Uint8Array, peer: PublicKey, additionalData?: Uint8Array): Promise<Ciphertext>;
    decrypt(encrypted: Ciphertext, peer: PublicKey, additionalData?: Uint8Array): Promise<Uint8Array>;
    matches(key: PublicKey): boolean;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PrivateKey;
}

declare class PrivateKeyBundleV2 implements privateKey.PrivateKeyBundleV2 {
    identityKey: SignedPrivateKey;
    preKeys: SignedPrivateKey[];
    version: number;
    private _publicKeyBundle?;
    constructor(bundle: privateKey.PrivateKeyBundleV2);
    static generate(wallet: Signer): Promise<PrivateKeyBundleV2>;
    getCurrentPreKey(): SignedPrivateKey;
    findPreKey(which: SignedPublicKey): SignedPrivateKey;
    addPreKey(): Promise<void>;
    getPublicKeyBundle(): SignedPublicKeyBundle;
    sharedSecret(peer: SignedPublicKeyBundle, myPreKey: SignedPublicKey, isRecipient: boolean): Promise<Uint8Array>;
    encode(): Uint8Array;
    equals(other: this): boolean;
    static fromLegacyBundle(bundle: PrivateKeyBundleV1): PrivateKeyBundleV2;
}
declare class PrivateKeyBundleV1 implements privateKey.PrivateKeyBundleV1 {
    identityKey: PrivateKey;
    preKeys: PrivateKey[];
    version: number;
    private _publicKeyBundle?;
    constructor(bundle: privateKey.PrivateKeyBundleV1);
    static generate(wallet?: Signer): Promise<PrivateKeyBundleV1>;
    getCurrentPreKey(): PrivateKey;
    findPreKey(which: PublicKey): PrivateKey;
    addPreKey(): Promise<void>;
    getPublicKeyBundle(): PublicKeyBundle;
    sharedSecret(peer: PublicKeyBundle | SignedPublicKeyBundle, myPreKey: PublicKey, isRecipient: boolean): Promise<Uint8Array>;
    encode(): Uint8Array;
}
declare type PrivateKeyBundle = PrivateKeyBundleV1 | PrivateKeyBundleV2;

declare function encrypt(plain: Uint8Array, secret: Uint8Array, additionalData?: Uint8Array): Promise<Ciphertext>;
declare function decrypt(encrypted: Ciphertext | ciphertext.Ciphertext, secret: Uint8Array, additionalData?: Uint8Array): Promise<Uint8Array>;

declare class AuthData implements authn.AuthData {
    walletAddr: string;
    createdNs: Long;
    constructor({ walletAddr, createdNs }: authn.AuthData);
    static create(walletAddr: string, timestamp?: Date): AuthData;
    static fromBytes(bytes: Uint8Array): AuthData;
    toBytes(): Uint8Array;
}

declare class Token implements authn.Token {
    identityKey: publicKey.PublicKey;
    authDataBytes: Uint8Array;
    authDataSignature: signature.Signature;
    private _authData?;
    constructor({ identityKey, authDataBytes, authDataSignature }: authn.Token);
    get authData(): AuthData;
    get ageMs(): number;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): Token;
    toBase64(): string;
}

declare type Flatten<T> = {
    [K in keyof T]: T[K];
};
declare type WithoutUndefined<T> = {
    [P in keyof T]: NonNullable<T[P]>;
};

/**
 * A Keystore is responsible for holding the user's XMTP private keys and using them to encrypt/decrypt/sign messages.
 * Keystores are instantiated using a `KeystoreProvider`
 */
interface Keystore {
    /**
     * Decrypt a batch of V1 messages
     */
    decryptV1(req: keystore.DecryptV1Request): Promise<keystore.DecryptResponse>;
    /**
     * Decrypt a batch of V2 messages
     */
    decryptV2(req: keystore.DecryptV2Request): Promise<keystore.DecryptResponse>;
    /**
     * Encrypt a batch of V1 messages
     */
    encryptV1(req: keystore.EncryptV1Request): Promise<keystore.EncryptResponse>;
    /**
     * Encrypt a batch of V2 messages
     */
    encryptV2(req: keystore.EncryptV2Request): Promise<keystore.EncryptResponse>;
    /**
     * Take a batch of invite messages and store the `TopicKeys` for later use in decrypting messages
     */
    saveInvites(req: keystore.SaveInvitesRequest): Promise<keystore.SaveInvitesResponse>;
    /**
     * Create a sealed/encrypted invite and store the Topic keys in the Keystore for later use.
     * The returned invite payload must be sent to the network for the other party to be able to communicate.
     */
    createInvite(req: keystore.CreateInviteRequest): Promise<keystore.CreateInviteResponse>;
    /**
     * Create an XMTP auth token to be used as a header on XMTP API requests
     */
    createAuthToken(req: keystore.CreateAuthTokenRequest): Promise<authn.Token>;
    /**
     * Sign the provided digest with either the `IdentityKey` or a specified `PreKey`
     */
    signDigest(req: keystore.SignDigestRequest): Promise<signature.Signature>;
    /**
     * Get a list of V2 conversations
     */
    getV2Conversations(): Promise<conversationReference.ConversationReference[]>;
    /**
     * Get the `PublicKeyBundle` associated with the Keystore's private keys
     */
    getPublicKeyBundle(): Promise<publicKey.PublicKeyBundle>;
    /**
     * Export the private keys. May throw an error if the keystore implementation does not allow this operation
     */
    getPrivateKeyBundle(): Promise<privateKey.PrivateKeyBundleV1>;
    /**
     * Get the account address of the wallet used to create the Keystore
     */
    getAccountAddress(): Promise<string>;
}
declare type TopicData = WithoutUndefined<keystore.TopicMap_TopicData>;

interface Persistence {
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
}

/**
 * InviteStore holds a simple map of topic -> TopicData and writes to the persistence layer on changes
 */
declare class InviteStore {
    private persistence?;
    private mutex;
    private topicMap;
    constructor(persistence?: Persistence, initialData?: Map<string, TopicData>);
    static create(persistence?: Persistence): Promise<InviteStore>;
    add(topicData: TopicData[]): Promise<void>;
    get topics(): TopicData[];
    lookup(topic: string): TopicData | undefined;
    private toBytes;
}

declare class LocalStoragePersistence implements Persistence {
    storage: Storage;
    constructor();
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
}

declare class PrefixedPersistence {
    prefix: string;
    persistence: Persistence;
    constructor(prefix: string, persistence: Persistence);
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
    private buildKey;
}

/**
 * EncryptedPersistence is a Persistence implementation that uses ECIES to encrypt all values
 * ECIES encryption protects against unauthorized reads, but not unauthorized writes.
 * A third party with access to the underlying store could write malicious data using the public key of the owner
 */
declare class EncryptedPersistence implements Persistence {
    private persistence;
    private privateKey;
    private privateKeyBytes;
    private publicKey;
    constructor(persistence: Persistence, privateKey: PrivateKey | SignedPrivateKey);
    getItem(key: string): Promise<Uint8Array | null>;
    setItem(key: string, value: Uint8Array): Promise<void>;
    private encrypt;
    private decrypt;
    private serializeEcies;
    private deserializeEcies;
}

declare class InMemoryKeystore implements Keystore {
    private v1Keys;
    private v2Keys;
    private inviteStore;
    private authenticator;
    private accountAddress;
    constructor(keys: PrivateKeyBundleV1, inviteStore: InviteStore);
    static create(keys: PrivateKeyBundleV1, persistence?: Persistence): Promise<InMemoryKeystore>;
    decryptV1(req: keystore.DecryptV1Request): Promise<keystore.DecryptResponse>;
    decryptV2(req: keystore.DecryptV2Request): Promise<keystore.DecryptResponse>;
    encryptV1(req: keystore.EncryptV1Request): Promise<keystore.EncryptResponse>;
    createAuthToken({ timestampNs, }: keystore.CreateAuthTokenRequest): Promise<authn.Token>;
    encryptV2(req: keystore.EncryptV2Request): Promise<keystore.EncryptResponse>;
    saveInvites(req: keystore.SaveInvitesRequest): Promise<keystore.SaveInvitesResponse>;
    createInvite(req: keystore.CreateInviteRequest): Promise<keystore.CreateInviteResponse>;
    signDigest(req: keystore.SignDigestRequest): Promise<signature.Signature>;
    getV2Conversations(): Promise<conversationReference.ConversationReference[]>;
    getPublicKeyBundle(): Promise<PublicKeyBundle>;
    getPrivateKeyBundle(): Promise<privateKey.PrivateKeyBundleV1>;
    getAccountAddress(): Promise<string>;
    lookupTopic(topic: string): WithoutUndefined<keystore.TopicMap_TopicData> | undefined;
}

interface Authenticator {
    createToken(timestamp?: Date): Promise<Token>;
}

declare const MessageApi: typeof messageApi.MessageApi;
declare const SortDirection: typeof messageApi.SortDirection;
declare const ApiUrls: {
    readonly local: "http://localhost:5555";
    readonly dev: "https://dev.xmtp.network";
    readonly production: "https://production.xmtp.network";
};
declare type QueryParams = {
    startTime?: Date;
    endTime?: Date;
    contentTopic: string;
};
declare type QueryAllOptions = {
    direction?: messageApi.SortDirection;
    limit?: number;
};
declare type QueryStreamOptions = Flatten<Omit<QueryAllOptions, 'limit'> & {
    pageSize?: number;
}>;
declare type Query = Flatten<QueryParams & QueryStreamOptions>;
declare type PublishParams = {
    contentTopic: string;
    message: Uint8Array;
    timestamp?: Date;
};
declare type SubscribeParams = {
    contentTopics: string[];
};
declare type ApiClientOptions = {
    maxRetries?: number;
    appVersion?: string;
};
declare type SubscribeCallback = NotifyStreamEntityArrival<messageApi.Envelope>;
declare type UnsubscribeFn = () => Promise<void>;
/**
 * ApiClient provides a wrapper for calling the GRPC Gateway generated code.
 * It adds some helpers for dealing with paginated data and automatically retries idempotent calls
 */
declare class ApiClient {
    pathPrefix: string;
    maxRetries: number;
    private authCache?;
    appVersion: string | undefined;
    version: string;
    constructor(pathPrefix: string, opts?: ApiClientOptions);
    private _query;
    private _batchQuery;
    private _publish;
    private _subscribe;
    query(params: QueryParams, { direction, limit, }: QueryAllOptions): Promise<messageApi.Envelope[]>;
    queryIterator(params: QueryParams, options: QueryStreamOptions): AsyncGenerator<messageApi.Envelope>;
    queryIteratePages({ contentTopic, startTime, endTime }: QueryParams, { direction, pageSize }: QueryStreamOptions): AsyncGenerator<messageApi.Envelope[]>;
    batchQuery(queries: Query[]): Promise<messageApi.Envelope[][]>;
    publish(messages: PublishParams[]): ReturnType<typeof MessageApi.Publish>;
    subscribe(params: SubscribeParams, callback: SubscribeCallback): UnsubscribeFn;
    private getToken;
    setAuthenticator(authenticator: Authenticator, cacheExpirySeconds?: number): void;
    headers(): Headers;
}

declare const buildContentTopic: (name: string) => string;
declare const buildDirectMessageTopic: (sender: string, recipient: string) => string;
declare const buildDirectMessageTopicV2: (randomString: string) => string;
declare const buildUserContactTopic: (walletAddr: string) => string;
declare const buildUserIntroTopic: (walletAddr: string) => string;
declare const buildUserInviteTopic: (walletAddr: string) => string;
declare const buildUserPrivateStoreTopic: (addrPrefixedKey: string) => string;

declare type EnvelopeMapper<Out> = (env: messageApi.Envelope) => Promise<Out>;
declare function mapPaginatedStream<Out>(gen: AsyncGenerator<messageApi.Envelope[]>, mapper: EnvelopeMapper<Out>): AsyncGenerator<Out[]>;

declare function dateToNs(date: Date): Long;
declare function nsToDate(ns: Long): Date;
declare const toNanoString: (d: Date | undefined) => undefined | string;
declare const fromNanoString: (s: string | undefined) => undefined | Date;

declare type InvitationContext = {
    conversationId: string;
    metadata: {
        [k: string]: string;
    };
};
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
declare class InvitationV1 implements invitation.InvitationV1 {
    topic: string;
    context: InvitationContext | undefined;
    aes256GcmHkdfSha256: invitation.InvitationV1_Aes256gcmHkdfsha256;
    constructor({ topic, context, aes256GcmHkdfSha256, }: invitation.InvitationV1);
    static createRandom(context?: invitation.InvitationV1_Context): InvitationV1;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): InvitationV1;
}
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
declare class SealedInvitationHeaderV1 implements invitation.SealedInvitationHeaderV1 {
    sender: SignedPublicKeyBundle;
    recipient: SignedPublicKeyBundle;
    createdNs: Long;
    constructor({ sender, recipient, createdNs, }: invitation.SealedInvitationHeaderV1);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationHeaderV1;
}
declare class SealedInvitationV1 implements invitation.SealedInvitationV1 {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    private _header?;
    private _invitation?;
    constructor({ headerBytes, ciphertext }: invitation.SealedInvitationV1);
    /**
     * Accessor method for the full header object
     */
    get header(): SealedInvitationHeaderV1;
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewer: PrivateKeyBundleV2): Promise<InvitationV1>;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationV1;
}
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
declare class SealedInvitation implements invitation.SealedInvitation {
    v1: SealedInvitationV1 | undefined;
    constructor({ v1 }: invitation.SealedInvitation);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitation;
    static fromEnvelope(env: messageApi.Envelope): Promise<SealedInvitation>;
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static createV1({ sender, recipient, created, invitation, }: {
        sender: PrivateKeyBundleV2;
        recipient: SignedPublicKeyBundle;
        created: Date;
        invitation: InvitationV1;
    }): Promise<SealedInvitation>;
}

/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
declare class Conversations {
    private client;
    private v1Cache;
    private v2Mutex;
    constructor(client: Client);
    /**
     * List all conversations with the current wallet found in the network.
     */
    list(): Promise<Conversation[]>;
    private listV1Conversations;
    /**
     * List all V2 conversations
     */
    private listV2Conversations;
    private getV2ConversationsFromKeystore;
    updateV2Conversations(startTime?: Date): Promise<ConversationV2[]>;
    private decodeInvites;
    private saveInviteResponseToConversation;
    private conversationReferenceToV2;
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream(): Promise<Stream<Conversation>>;
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages(): Promise<AsyncGenerator<DecodedMessage>>;
    private getIntroductionPeers;
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress: string, context?: InvitationContext): Promise<Conversation>;
    private createV2Convo;
    private getPeerAddress;
}

declare class ContentTypeId {
    authorityId: string;
    typeId: string;
    versionMajor: number;
    versionMinor: number;
    constructor(obj: content.ContentTypeId);
    toString(): string;
    sameAs(id: ContentTypeId): boolean;
}
interface EncodedContent {
    type: ContentTypeId;
    parameters: Record<string, string>;
    fallback?: string;
    compression?: number;
    content: Uint8Array;
}
interface CodecRegistry {
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
}
interface ContentCodec<T> {
    contentType: ContentTypeId;
    encode(content: T, registry: CodecRegistry): EncodedContent;
    decode(content: EncodedContent, registry: CodecRegistry): T;
}
declare const ContentTypeFallback: ContentTypeId;

/**
 * Where message backups should be stored
 */
declare enum BackupType {
    none = 0,
    xmtpTopicStore = 1
}
interface BackupClient {
    get backupType(): BackupType;
}

declare type KeystoreProviderOptions = {
    env: XmtpEnv;
    persistConversations: boolean;
    privateKeyOverride?: Uint8Array;
} & PreEventCallbackOptions;
/**
 * A Keystore Provider is responsible for either creating a Keystore instance or throwing a KeystoreUnavailableError
 * It is typically used once on application startup to bootstrap the Keystore and load/decrypt the user's private keys
 */
interface KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

/**
 * KeyGeneratorKeystoreProvider will create a new XMTP `PrivateKeyBundle` and persist it to the network
 * This provider should always be specified last in the list of `keystoreProviders` on client creation,
 * as it will overwrite any XMTP identities already on the network
 */
declare class KeyGeneratorKeystoreProvider implements KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

/**
 * NetworkKeystoreProvider will look on the XMTP network for an `EncryptedPrivateKeyBundle`
 * on the user's private storage topic. If found, will decrypt the bundle using a wallet
 * signature and instantiate a Keystore instance using the decrypted value.
 */
declare class NetworkKeystoreProvider implements KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions, apiClient: ApiClient, wallet?: Signer): Promise<Keystore>;
}

/**
 * StaticKeystoreProvider will look for a `privateKeyOverride` in the provided options,
 * and bootstrap a Keystore using those options if provided.
 *
 * If no `privateKeyOverride` is supplied will throw a `KeystoreProviderUnavailableError` causing
 * the client to continue iterating through the `KeystoreProviders` list.
 */
declare class StaticKeystoreProvider implements KeystoreProvider {
    newKeystore(opts: KeystoreProviderOptions): Promise<Keystore>;
}

declare const Compression: typeof content.Compression;
declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    startTime?: Date;
    endTime?: Date;
    limit?: number;
    direction?: messageApi.SortDirection;
};
declare type ListMessagesPaginatedOptions = {
    startTime?: Date;
    endTime?: Date;
    pageSize?: number;
    direction?: messageApi.SortDirection;
};

declare type SendOptions = {
    contentType?: ContentTypeId;
    contentFallback?: string;
    compression?: content.Compression;
    timestamp?: Date;
    ephemeral?: boolean;
};
declare type XmtpEnv = keyof typeof ApiUrls;
declare type PreEventCallback = () => Promise<void>;
/**
 * Network startup options
 */
declare type NetworkOptions = {
    /**
     * Specify which XMTP environment to connect to. (default: `dev`)
     */
    env: XmtpEnv;
    /**
     * apiUrl can be used to override the `env` flag and connect to a
     * specific endpoint
     */
    apiUrl: string | undefined;
    /**
     * identifier that's included with API requests.
     *
     * For example, you can use the following format:
     * `appVersion: APP_NAME + '/' + APP_VERSION`.
     * Setting this value provides telemetry that shows which apps are
     * using the XMTP client SDK. This information can help XMTP developers
     * provide app support, especially around communicating important
     * SDK updates, including deprecations and required upgrades.
     */
    appVersion?: string;
    /**
     * Skip publishing the user's contact bundle as part of Client startup.
     *
     * This flag should be used with caution, as we rely on contact publishing to
     * let other users know your public key and periodically run migrations on
     * this data with new SDK versions.
     *
     * Your application should have this flag set to `false` at least _some_ of the
     * time.
     *
     * The most common use-case for setting this to `true` is cases where the Client
     * instance is very short-lived. For example, spinning up a Client to decrypt
     * a push notification.
     */
    skipContactPublishing: boolean;
};
declare type ContentOptions = {
    /**
     * Allow configuring codecs for additional content types
     */
    codecs: ContentCodec<any>[];
    /**
     * Set the maximum content size in bytes that is allowed by the Client.
     * Currently only checked when decompressing compressed content.
     */
    maxContentSize: number;
};
declare type KeyStoreOptions = {
    /**
     * Provide an array of KeystoreProviders.
     * The client will attempt to use each one in sequence until one successfully
     * returns a Keystore instance
     */
    keystoreProviders: KeystoreProvider[];
    /**
     * Enable the Keystore to persist conversations in the provided storage interface
     */
    persistConversations: boolean;
    /**
     * Provide a XMTP PrivateKeyBundle encoded as a Uint8Array.
     * A bundle can be retried using `Client.getKeys(...)`
     */
    privateKeyOverride?: Uint8Array;
};
declare type LegacyOptions = {
    publishLegacyContact?: boolean;
};
declare type PreEventCallbackOptions = {
    /**
     * preCreateIdentityCallback will be called immediately before a Create Identity
     * wallet signature is requested from the user.
     *
     * The provided function must return a Promise and will be awaited, allowing the
     * developer to update the UI or insert a required delay before requesting a signature.
     */
    preCreateIdentityCallback?: PreEventCallback;
    /**
     * preEnableIdentityCallback will be called immediately before an Enable Identity
     * wallet signature is requested from the user.
     *
     * The provided function must return a Promise and will be awaited, allowing the
     * developer to update the UI or insert a required delay before requesting a signature.
     */
    preEnableIdentityCallback?: PreEventCallback;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
declare type ClientOptions = Flatten<NetworkOptions & KeyStoreOptions & ContentOptions & LegacyOptions & PreEventCallbackOptions>;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
declare class Client {
    address: string;
    keystore: Keystore;
    apiClient: ApiClient;
    contacts: Set<string>;
    publicKeyBundle: PublicKeyBundle;
    private knownPublicKeyBundles;
    private _backupClient;
    private _conversations;
    private _codecs;
    private _maxContentSize;
    constructor(publicKeyBundle: PublicKeyBundle, apiClient: ApiClient, backupClient: BackupClient, keystore: Keystore);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations;
    get backupType(): BackupType;
    get signedPublicKeyBundle(): SignedPublicKeyBundle;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Client>;
    /**
     * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.
     *
     * This bundle can then be provided as `privateKeyOverride` in a
     * subsequent call to `Client.create(...)`
     *
     * Be very careful with these keys, as they can be used to
     * impersonate a user on the XMTP network and read the user's
     * messages.
     */
    static getKeys(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Uint8Array>;
    private static setupBackupClient;
    private init;
    close(): Promise<void>;
    private ensureUserContactPublished;
    publishUserContact(legacy?: boolean): Promise<void>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     *
     * This throws if either the address is invalid or the contact is not published.
     * See also [#canMessage].
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined>;
    /**
     * Identical to getUserContact but for multiple peer addresses
     */
    getUserContacts(peerAddresses: string[]): Promise<(PublicKeyBundle | SignedPublicKeyBundle | undefined)[]>;
    /**
     * Used to force getUserContact fetch contact from the network.
     */
    forgetContact(peerAddress: string): void;
    canMessage(peerAddress: string): Promise<boolean>;
    canMessage(peerAddress: string[]): Promise<boolean[]>;
    static canMessage(peerAddress: string, opts?: Partial<NetworkOptions>): Promise<boolean>;
    static canMessage(peerAddress: string[], opts?: Partial<NetworkOptions>): Promise<boolean[]>;
    private validateEnvelope;
    /**
     * Low level method for publishing envelopes to the XMTP network with
     * no pre-processing or encryption applied.
     *
     * Primarily used internally
     *
     * @param envelopes PublishParams[]
     */
    publishEnvelopes(envelopes: PublishParams[]): Promise<void>;
    /**
     * Register a codec to be automatically used for encoding/decoding
     * messages of the given Content Type
     */
    registerCodec(codec: ContentCodec<any>): void;
    /**
     * Find a matching codec for a given `ContentTypeId` from the
     * client's codec registry
     */
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    /**
     * Convert arbitrary content into a serialized `EncodedContent` instance
     * with the given options
     */
    encodeContent(content: any, options?: SendOptions): Promise<Uint8Array>;
    listInvitations(opts?: ListMessagesOptions): Promise<messageApi.Envelope[]>;
    /**
     * List stored messages from the specified topic.
     *
     * A specified mapper function will be applied to each envelope.
     * If the mapper function throws an error during processing, the
     * envelope will be discarded.
     */
    listEnvelopes<Out>(topic: string, mapper: EnvelopeMapper<Out>, opts?: ListMessagesOptions): Promise<Out[]>;
    /**
     * List messages on a given set of content topics, yielding one page at a time
     */
    listEnvelopesPaginated<Out>(contentTopic: string, mapper: EnvelopeMapper<Out>, opts?: ListMessagesPaginatedOptions): AsyncGenerator<Out[]>;
}

declare type MessageDecoder<M> = (env: messageApi.Envelope) => Promise<M | undefined>;
declare type ContentTopicUpdater<M> = (msg: M) => string[] | undefined;
/**
 * Stream implements an Asynchronous Iterable over messages received from a topic.
 * As such can be used with constructs like for-await-of, yield*, array destructing, etc.
 */
declare class Stream<T> {
    topics: string[];
    client: Client;
    messages: T[];
    resolvers: ((value: IteratorResult<T>) => void)[];
    callback: ((env: messageApi.Envelope) => Promise<void>) | undefined;
    unsubscribeFn?: UnsubscribeFn;
    constructor(client: Client, topics: string[], decoder: MessageDecoder<T>, contentTopicUpdater?: ContentTopicUpdater<T>);
    private newMessageCallback;
    private start;
    static create<T>(client: Client, topics: string[], decoder: MessageDecoder<T>, contentTopicUpdater?: ContentTopicUpdater<T>): Promise<Stream<T>>;
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    return(): Promise<IteratorResult<T>>;
    next(): Promise<IteratorResult<T>>;
    private resubscribeToTopics;
}

declare class PreparedMessage {
    messageEnvelope: Envelope;
    onSend: () => Promise<void>;
    constructor(messageEnvelope: Envelope, onSend: () => Promise<void>);
    messageID(): Promise<string>;
    send(): Promise<void>;
}

/**
 * Conversation represents either a V1 or V2 conversation with a common set of methods.
 */
interface Conversation {
    /**
     * The wallet address connected to the client
     */
    clientAddress: string;
    /**
     * A unique identifier for a conversation. Each conversation is stored on the network on one topic
     */
    topic: string;
    /**
     * A unique identifier for ephemeral envelopes for a conversation.
     */
    ephemeralTopic: string;
    /**
     * The wallet address of the other party in the conversation
     */
    peerAddress: string;
    /**
     * Timestamp the conversation was created at
     */
    createdAt: Date;
    /**
     * Optional field containing the `conversationId` and `metadata` for V2 conversations.
     * Will always be undefined on V1 conversations
     */
    context?: InvitationContext | undefined;
    /**
     * Retrieve messages in this conversation. Default to returning all messages.
     *
     * If only a subset is required, results can be narrowed by specifying a start/end
     * timestamp.
     *
     * ```ts
     * // Get all messages in the past 24 hours
     * const messages = await conversation.messages({
     *    startTime: new Date(+new Date() - 86_400)
     * })
     * ```
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    /**
     * @deprecated
     */
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    /**
     * Takes a XMTP envelope as input and will decrypt and decode it
     * returning a `DecodedMessage` instance.
     */
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
    /**
     * Return a `Stream` of new messages in this conversation.
     *
     * Stream instances are async generators and can be used in
     * `for await` statements.
     *
     * ```ts
     * for await (const message of await conversation.stream()) {
     *    console.log(message.content)
     * }
     * ```
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    /**
     * Send a message into the conversation
     *
     * ## Example
     * ```ts
     * await conversation.send('Hello world') // returns a `DecodedMessage` instance
     * ```
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    /**
     * Return a `PreparedMessage` that has contains the message ID
     * of the message that will be sent.
     */
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    /**
     * Return a `Stream` of new ephemeral messages from this conversation's
     * ephemeral topic.
     *
     * Stream instances are async generators and can be used in
     * `for await` statements.
     *
     * ```ts
     * for await (const message of await conversation.streamEphemeral()) {
     *    console.log(message.content)
     * }
     * ```
     */
    streamEphemeral(): Promise<Stream<DecodedMessage>>;
}
/**
 * ConversationV2
 */
declare class ConversationV2 implements Conversation {
    client: Client;
    topic: string;
    peerAddress: string;
    createdAt: Date;
    context?: InvitationContext;
    constructor(client: Client, topic: string, peerAddress: string, createdAt: Date, context: InvitationContext | undefined);
    get clientAddress(): string;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    get ephemeralTopic(): string;
    streamEphemeral(): Promise<Stream<DecodedMessage>>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    /**
     * Send a message into the conversation
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    createMessage(payload: Uint8Array, timestamp?: Date): Promise<MessageV2>;
    private decryptBatch;
    private buildDecryptRequest;
    private encryptMessage;
    private buildDecodedMessage;
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    processEnvelope(env: messageApi.Envelope): Promise<MessageV2>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
}

declare class MessageBase {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    contentType?: ContentTypeId;
    error?: Error;
    /**
     * Identifier that is deterministically derived from the bytes of the message
     * header and ciphertext, where all those bytes are authenticated. This can
     * be used in determining uniqueness of messages.
     */
    id: string;
    private bytes;
    constructor(id: string, bytes: Uint8Array, obj: message.Message);
    toBytes(): Uint8Array;
}
declare class MessageV1 extends MessageBase implements message.MessageV1 {
    header: message.MessageHeaderV1;
    senderAddress: string | undefined;
    conversation: undefined;
    constructor(id: string, bytes: Uint8Array, obj: message.Message, header: message.MessageHeaderV1, senderAddress: string | undefined);
    static create(obj: message.Message, header: message.MessageHeaderV1, bytes: Uint8Array): Promise<MessageV1>;
    get sent(): Date;
    get recipientAddress(): string | undefined;
    decrypt(keystore: Keystore, myPublicKeyBundle: PublicKeyBundle): Promise<Uint8Array>;
    static fromBytes(bytes: Uint8Array): Promise<MessageV1>;
    static encode(keystore: Keystore, payload: Uint8Array, sender: PublicKeyBundle, recipient: PublicKeyBundle, timestamp: Date): Promise<MessageV1>;
}
declare class MessageV2 extends MessageBase implements message.MessageV2 {
    senderAddress: string | undefined;
    private header;
    constructor(id: string, bytes: Uint8Array, obj: message.Message, header: message.MessageHeaderV2);
    static create(obj: message.Message, header: message.MessageHeaderV2, bytes: Uint8Array): Promise<MessageV2>;
    get sent(): Date;
}
declare type Message = MessageV1 | MessageV2;
declare class DecodedMessage {
    id: string;
    messageVersion: 'v1' | 'v2';
    senderAddress: string;
    recipientAddress?: string;
    sent: Date;
    contentTopic: string;
    conversation: Conversation;
    contentType: ContentTypeId;
    content: any;
    error?: Error;
    contentBytes: Uint8Array;
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentBytes, contentType, contentTopic, content, sent, error, }: Omit<DecodedMessage, 'toBytes'>);
    toBytes(): Uint8Array;
    static fromBytes(data: Uint8Array, client: Client): Promise<DecodedMessage>;
    static fromV1Message(message: MessageV1, content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType: ContentTypeId, contentBytes: Uint8Array, contentTopic: string, conversation: Conversation, error?: Error): DecodedMessage;
    static fromV2Message(message: MessageV2, content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType: ContentTypeId, contentTopic: string, contentBytes: Uint8Array, conversation: Conversation, senderAddress: string, error?: Error): DecodedMessage;
}
declare function decodeContent(contentBytes: Uint8Array, client: Client): Promise<{
    content: any;
    contentType: ContentTypeId;
    error: Error | undefined;
}>;

declare const ContentTypeText: ContentTypeId;
declare class TextCodec implements ContentCodec<string> {
    get contentType(): ContentTypeId;
    encode(content: string): EncodedContent;
    decode(content: EncodedContent): string;
}

declare const ContentTypeTypingNotification: ContentTypeId;
declare type TypingNotification = {
    timestamp: Date;
    typerAddress: string;
    isFinished: boolean;
};
declare class TypingNotificationCodec implements ContentCodec<TypingNotification> {
    get contentType(): ContentTypeId;
    encode(content: TypingNotification): EncodedContent;
    decode(content: EncodedContent): TypingNotification;
}

declare const ContentTypeComposite: ContentTypeId;
declare type Composite = {
    type: ContentTypeId;
    content: any;
} | {
    parts: Composite[];
};
declare class CompositeCodec implements ContentCodec<Composite> {
    get contentType(): ContentTypeId;
    encode(content: Composite, codecs: CodecRegistry): EncodedContent;
    decode(content: EncodedContent, codecs: CodecRegistry): Composite;
    private toProto;
    private fromProto;
}

declare function decodeContactBundle(bytes: Uint8Array): PublicKeyBundle | SignedPublicKeyBundle;

export { ApiUrls, Ciphertext, Client, ClientOptions, CodecRegistry, Composite, CompositeCodec, Compression, ContentCodec, ContentOptions, ContentTypeComposite, ContentTypeFallback, ContentTypeId, ContentTypeText, ContentTypeTypingNotification, Conversation, Conversations, DecodedMessage, EncodedContent, EncryptedPersistence, InMemoryKeystore, InvitationContext, KeyGeneratorKeystoreProvider, KeyStoreOptions, Keystore, KeystoreProvider, LegacyOptions, ListMessagesOptions, ListMessagesPaginatedOptions, LocalStoragePersistence, Message, MessageV1, MessageV2, NetworkKeystoreProvider, NetworkOptions, Persistence, PrefixedPersistence, PrivateKey, PrivateKeyBundle, PublicKey, PublicKeyBundle, SealedInvitation, SendOptions, Signature, SignedPublicKey, SignedPublicKeyBundle, Signer, SortDirection, StaticKeystoreProvider, Stream, TextCodec, TopicData, TypingNotification, TypingNotificationCodec, buildContentTopic, buildDirectMessageTopic, buildDirectMessageTopicV2, buildUserContactTopic, buildUserIntroTopic, buildUserInviteTopic, buildUserPrivateStoreTopic, dateToNs, decodeContactBundle, decodeContent, decrypt, encrypt, fromNanoString, mapPaginatedStream, nsToDate, toNanoString };
