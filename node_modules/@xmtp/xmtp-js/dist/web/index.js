import { utils } from 'ethers';
import wn from 'long';
import { ciphertext, privateKey, signature, publicKey, message, content, messageApi, contact, invitation, keystore, composite, fetcher, authn } from '@xmtp/proto';
import * as Q from '@noble/secp256k1';
import { Mutex } from 'async-mutex';
import Es from 'elliptic';

var Bi=Object.create;var hn=Object.defineProperty;var Si=Object.getOwnPropertyDescriptor;var ki=Object.getOwnPropertyNames;var Ti=Object.getPrototypeOf,Mi=Object.prototype.hasOwnProperty;var gn=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports);var Di=(i,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of ki(e))!Mi.call(i,s)&&s!==t&&hn(i,s,{get:()=>e[s],enumerable:!(r=Si(e,s))||r.enumerable});return i};var vn=(i,e,t)=>(t=i!=null?Bi(Ti(i)):{},Di(e||!i||!i.__esModule?hn(t,"default",{value:i,enumerable:!0}):t,i));var Kn=gn((ao,Pn)=>{Pn.exports={webcrypto:window.crypto};});var jn=gn((Ec,Ar)=>{(function(){var i="input is invalid type",e="finalize already called",t=typeof window=="object",r=t?window:{};r.JS_SHA3_NO_WINDOW&&(t=!1);var s=!t&&typeof self=="object",o=!r.JS_SHA3_NO_NODE_JS&&typeof process=="object"&&process.versions&&process.versions.node;o?r=global:s&&(r=self);var a=!r.JS_SHA3_NO_COMMON_JS&&typeof Ar=="object"&&Ar.exports,c=typeof define=="function"&&define.amd,p=!r.JS_SHA3_NO_ARRAY_BUFFER&&typeof ArrayBuffer<"u",y="0123456789abcdef".split(""),f=[31,7936,2031616,520093696],K=[4,1024,262144,67108864],me=[1,256,65536,16777216],fe=[6,1536,393216,100663296],I=[0,8,16,24],Oe=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],on=[224,256,384,512],kr=[128,256],an=["hex","buffer","arrayBuffer","array","digest"],cn={128:168,256:136};(r.JS_SHA3_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(n){return Object.prototype.toString.call(n)==="[object Array]"}),p&&(r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(n){return typeof n=="object"&&n.buffer&&n.buffer.constructor===ArrayBuffer});for(var pn=function(n,d,u){return function(l){return new B(n,d,n).update(l)[u]()}},dn=function(n,d,u){return function(l,m){return new B(n,d,m).update(l)[u]()}},un=function(n,d,u){return function(l,m,g,v){return ue["cshake"+n].update(l,m,g,v)[u]()}},yn=function(n,d,u){return function(l,m,g,v){return ue["kmac"+n].update(l,m,g,v)[u]()}},mt=function(n,d,u,l){for(var m=0;m<an.length;++m){var g=an[m];n[g]=d(u,l,g);}return n},ln=function(n,d){var u=pn(n,d,"hex");return u.create=function(){return new B(n,d,n)},u.update=function(l){return u.create().update(l)},mt(u,pn,n,d)},Ei=function(n,d){var u=dn(n,d,"hex");return u.create=function(l){return new B(n,d,l)},u.update=function(l,m){return u.create(m).update(l)},mt(u,dn,n,d)},Ai=function(n,d){var u=cn[n],l=un(n,d,"hex");return l.create=function(m,g,v){return !g&&!v?ue["shake"+n].create(m):new B(n,d,m).bytepad([g,v],u)},l.update=function(m,g,v,h){return l.create(g,v,h).update(m)},mt(l,un,n,d)},xi=function(n,d){var u=cn[n],l=yn(n,d,"hex");return l.create=function(m,g,v){return new Mr(n,d,g).bytepad(["KMAC",v],u).bytepad([m],u)},l.update=function(m,g,v,h){return l.create(m,v,h).update(g)},mt(l,yn,n,d)},mn=[{name:"keccak",padding:me,bits:on,createMethod:ln},{name:"sha3",padding:fe,bits:on,createMethod:ln},{name:"shake",padding:f,bits:kr,createMethod:Ei},{name:"cshake",padding:K,bits:kr,createMethod:Ai},{name:"kmac",padding:K,bits:kr,createMethod:xi}],ue={},je=[],he=0;he<mn.length;++he)for(var _e=mn[he],ft=_e.bits,Ye=0;Ye<ft.length;++Ye){var Tr=_e.name+"_"+ft[Ye];if(je.push(Tr),ue[Tr]=_e.createMethod(ft[Ye],_e.padding),_e.name!=="sha3"){var fn=_e.name+ft[Ye];je.push(fn),ue[fn]=ue[Tr];}}function B(n,d,u){this.blocks=[],this.s=[],this.padding=d,this.outputBits=u,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(n<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=u>>5,this.extraBytes=(u&31)>>3;for(var l=0;l<50;++l)this.s[l]=0;}B.prototype.update=function(n){if(this.finalized)throw new Error(e);var d,u=typeof n;if(u!=="string"){if(u==="object"){if(n===null)throw new Error(i);if(p&&n.constructor===ArrayBuffer)n=new Uint8Array(n);else if(!Array.isArray(n)&&(!p||!ArrayBuffer.isView(n)))throw new Error(i)}else throw new Error(i);d=!0;}for(var l=this.blocks,m=this.byteCount,g=n.length,v=this.blockCount,h=0,S=this.s,w,C;h<g;){if(this.reset)for(this.reset=!1,l[0]=this.block,w=1;w<v+1;++w)l[w]=0;if(d)for(w=this.start;h<g&&w<m;++h)l[w>>2]|=n[h]<<I[w++&3];else for(w=this.start;h<g&&w<m;++h)C=n.charCodeAt(h),C<128?l[w>>2]|=C<<I[w++&3]:C<2048?(l[w>>2]|=(192|C>>6)<<I[w++&3],l[w>>2]|=(128|C&63)<<I[w++&3]):C<55296||C>=57344?(l[w>>2]|=(224|C>>12)<<I[w++&3],l[w>>2]|=(128|C>>6&63)<<I[w++&3],l[w>>2]|=(128|C&63)<<I[w++&3]):(C=65536+((C&1023)<<10|n.charCodeAt(++h)&1023),l[w>>2]|=(240|C>>18)<<I[w++&3],l[w>>2]|=(128|C>>12&63)<<I[w++&3],l[w>>2]|=(128|C>>6&63)<<I[w++&3],l[w>>2]|=(128|C&63)<<I[w++&3]);if(this.lastByteIndex=w,w>=m){for(this.start=w-m,this.block=l[v],w=0;w<v;++w)S[w]^=l[w];Je(S),this.reset=!0;}else this.start=w;}return this},B.prototype.encode=function(n,d){var u=n&255,l=1,m=[u];for(n=n>>8,u=n&255;u>0;)m.unshift(u),n=n>>8,u=n&255,++l;return d?m.push(l):m.unshift(l),this.update(m),m.length},B.prototype.encodeString=function(n){var d,u=typeof n;if(u!=="string"){if(u==="object"){if(n===null)throw new Error(i);if(p&&n.constructor===ArrayBuffer)n=new Uint8Array(n);else if(!Array.isArray(n)&&(!p||!ArrayBuffer.isView(n)))throw new Error(i)}else throw new Error(i);d=!0;}var l=0,m=n.length;if(d)l=m;else for(var g=0;g<n.length;++g){var v=n.charCodeAt(g);v<128?l+=1:v<2048?l+=2:v<55296||v>=57344?l+=3:(v=65536+((v&1023)<<10|n.charCodeAt(++g)&1023),l+=4);}return l+=this.encode(l*8),this.update(n),l},B.prototype.bytepad=function(n,d){for(var u=this.encode(d),l=0;l<n.length;++l)u+=this.encodeString(n[l]);var m=d-u%d,g=[];return g.length=m,this.update(g),this},B.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var n=this.blocks,d=this.lastByteIndex,u=this.blockCount,l=this.s;if(n[d>>2]|=this.padding[d&3],this.lastByteIndex===this.byteCount)for(n[0]=n[u],d=1;d<u+1;++d)n[d]=0;for(n[u-1]|=2147483648,d=0;d<u;++d)l[d]^=n[d];Je(l);}},B.prototype.toString=B.prototype.hex=function(){this.finalize();for(var n=this.blockCount,d=this.s,u=this.outputBlocks,l=this.extraBytes,m=0,g=0,v="",h;g<u;){for(m=0;m<n&&g<u;++m,++g)h=d[m],v+=y[h>>4&15]+y[h&15]+y[h>>12&15]+y[h>>8&15]+y[h>>20&15]+y[h>>16&15]+y[h>>28&15]+y[h>>24&15];g%n===0&&(Je(d),m=0);}return l&&(h=d[m],v+=y[h>>4&15]+y[h&15],l>1&&(v+=y[h>>12&15]+y[h>>8&15]),l>2&&(v+=y[h>>20&15]+y[h>>16&15])),v},B.prototype.arrayBuffer=function(){this.finalize();var n=this.blockCount,d=this.s,u=this.outputBlocks,l=this.extraBytes,m=0,g=0,v=this.outputBits>>3,h;l?h=new ArrayBuffer(u+1<<2):h=new ArrayBuffer(v);for(var S=new Uint32Array(h);g<u;){for(m=0;m<n&&g<u;++m,++g)S[g]=d[m];g%n===0&&Je(d);}return l&&(S[m]=d[m],h=h.slice(0,v)),h},B.prototype.buffer=B.prototype.arrayBuffer,B.prototype.digest=B.prototype.array=function(){this.finalize();for(var n=this.blockCount,d=this.s,u=this.outputBlocks,l=this.extraBytes,m=0,g=0,v=[],h,S;g<u;){for(m=0;m<n&&g<u;++m,++g)h=g<<2,S=d[m],v[h]=S&255,v[h+1]=S>>8&255,v[h+2]=S>>16&255,v[h+3]=S>>24&255;g%n===0&&Je(d);}return l&&(h=g<<2,S=d[m],v[h]=S&255,l>1&&(v[h+1]=S>>8&255),l>2&&(v[h+2]=S>>16&255)),v};function Mr(n,d,u){B.call(this,n,d,u);}Mr.prototype=new B,Mr.prototype.finalize=function(){return this.encode(this.outputBits,!0),B.prototype.finalize.call(this)};var Je=function(n){var d,u,l,m,g,v,h,S,w,C,ht,gt,vt,wt,bt,Pt,Kt,Ct,Et,At,xt,Bt,St,kt,Tt,Mt,Dt,Ut,It,Nt,Rt,Vt,Ot,_t,Ft,Lt,Ht,qt,zt,$t,Xt,Wt,Gt,Qt,jt,Yt,Jt,Zt,er,tr,rr,nr,ir,sr,or,ar,cr,pr,dr,ur,yr,lr,mr;for(l=0;l<48;l+=2)m=n[0]^n[10]^n[20]^n[30]^n[40],g=n[1]^n[11]^n[21]^n[31]^n[41],v=n[2]^n[12]^n[22]^n[32]^n[42],h=n[3]^n[13]^n[23]^n[33]^n[43],S=n[4]^n[14]^n[24]^n[34]^n[44],w=n[5]^n[15]^n[25]^n[35]^n[45],C=n[6]^n[16]^n[26]^n[36]^n[46],ht=n[7]^n[17]^n[27]^n[37]^n[47],gt=n[8]^n[18]^n[28]^n[38]^n[48],vt=n[9]^n[19]^n[29]^n[39]^n[49],d=gt^(v<<1|h>>>31),u=vt^(h<<1|v>>>31),n[0]^=d,n[1]^=u,n[10]^=d,n[11]^=u,n[20]^=d,n[21]^=u,n[30]^=d,n[31]^=u,n[40]^=d,n[41]^=u,d=m^(S<<1|w>>>31),u=g^(w<<1|S>>>31),n[2]^=d,n[3]^=u,n[12]^=d,n[13]^=u,n[22]^=d,n[23]^=u,n[32]^=d,n[33]^=u,n[42]^=d,n[43]^=u,d=v^(C<<1|ht>>>31),u=h^(ht<<1|C>>>31),n[4]^=d,n[5]^=u,n[14]^=d,n[15]^=u,n[24]^=d,n[25]^=u,n[34]^=d,n[35]^=u,n[44]^=d,n[45]^=u,d=S^(gt<<1|vt>>>31),u=w^(vt<<1|gt>>>31),n[6]^=d,n[7]^=u,n[16]^=d,n[17]^=u,n[26]^=d,n[27]^=u,n[36]^=d,n[37]^=u,n[46]^=d,n[47]^=u,d=C^(m<<1|g>>>31),u=ht^(g<<1|m>>>31),n[8]^=d,n[9]^=u,n[18]^=d,n[19]^=u,n[28]^=d,n[29]^=u,n[38]^=d,n[39]^=u,n[48]^=d,n[49]^=u,wt=n[0],bt=n[1],Yt=n[11]<<4|n[10]>>>28,Jt=n[10]<<4|n[11]>>>28,Ut=n[20]<<3|n[21]>>>29,It=n[21]<<3|n[20]>>>29,ur=n[31]<<9|n[30]>>>23,yr=n[30]<<9|n[31]>>>23,Wt=n[40]<<18|n[41]>>>14,Gt=n[41]<<18|n[40]>>>14,_t=n[2]<<1|n[3]>>>31,Ft=n[3]<<1|n[2]>>>31,Pt=n[13]<<12|n[12]>>>20,Kt=n[12]<<12|n[13]>>>20,Zt=n[22]<<10|n[23]>>>22,er=n[23]<<10|n[22]>>>22,Nt=n[33]<<13|n[32]>>>19,Rt=n[32]<<13|n[33]>>>19,lr=n[42]<<2|n[43]>>>30,mr=n[43]<<2|n[42]>>>30,sr=n[5]<<30|n[4]>>>2,or=n[4]<<30|n[5]>>>2,Lt=n[14]<<6|n[15]>>>26,Ht=n[15]<<6|n[14]>>>26,Ct=n[25]<<11|n[24]>>>21,Et=n[24]<<11|n[25]>>>21,tr=n[34]<<15|n[35]>>>17,rr=n[35]<<15|n[34]>>>17,Vt=n[45]<<29|n[44]>>>3,Ot=n[44]<<29|n[45]>>>3,kt=n[6]<<28|n[7]>>>4,Tt=n[7]<<28|n[6]>>>4,ar=n[17]<<23|n[16]>>>9,cr=n[16]<<23|n[17]>>>9,qt=n[26]<<25|n[27]>>>7,zt=n[27]<<25|n[26]>>>7,At=n[36]<<21|n[37]>>>11,xt=n[37]<<21|n[36]>>>11,nr=n[47]<<24|n[46]>>>8,ir=n[46]<<24|n[47]>>>8,Qt=n[8]<<27|n[9]>>>5,jt=n[9]<<27|n[8]>>>5,Mt=n[18]<<20|n[19]>>>12,Dt=n[19]<<20|n[18]>>>12,pr=n[29]<<7|n[28]>>>25,dr=n[28]<<7|n[29]>>>25,$t=n[38]<<8|n[39]>>>24,Xt=n[39]<<8|n[38]>>>24,Bt=n[48]<<14|n[49]>>>18,St=n[49]<<14|n[48]>>>18,n[0]=wt^~Pt&Ct,n[1]=bt^~Kt&Et,n[10]=kt^~Mt&Ut,n[11]=Tt^~Dt&It,n[20]=_t^~Lt&qt,n[21]=Ft^~Ht&zt,n[30]=Qt^~Yt&Zt,n[31]=jt^~Jt&er,n[40]=sr^~ar&pr,n[41]=or^~cr&dr,n[2]=Pt^~Ct&At,n[3]=Kt^~Et&xt,n[12]=Mt^~Ut&Nt,n[13]=Dt^~It&Rt,n[22]=Lt^~qt&$t,n[23]=Ht^~zt&Xt,n[32]=Yt^~Zt&tr,n[33]=Jt^~er&rr,n[42]=ar^~pr&ur,n[43]=cr^~dr&yr,n[4]=Ct^~At&Bt,n[5]=Et^~xt&St,n[14]=Ut^~Nt&Vt,n[15]=It^~Rt&Ot,n[24]=qt^~$t&Wt,n[25]=zt^~Xt&Gt,n[34]=Zt^~tr&nr,n[35]=er^~rr&ir,n[44]=pr^~ur&lr,n[45]=dr^~yr&mr,n[6]=At^~Bt&wt,n[7]=xt^~St&bt,n[16]=Nt^~Vt&kt,n[17]=Rt^~Ot&Tt,n[26]=$t^~Wt&_t,n[27]=Xt^~Gt&Ft,n[36]=tr^~nr&Qt,n[37]=rr^~ir&jt,n[46]=ur^~lr&sr,n[47]=yr^~mr&or,n[8]=Bt^~wt&Pt,n[9]=St^~bt&Kt,n[18]=Vt^~kt&Mt,n[19]=Ot^~Tt&Dt,n[28]=Wt^~_t&Lt,n[29]=Gt^~Ft&Ht,n[38]=nr^~Qt&Yt,n[39]=ir^~jt&Jt,n[48]=lr^~sr&ar,n[49]=mr^~or&cr,n[0]^=Oe[l],n[1]^=Oe[l+1];};if(a)Ar.exports=ue;else {for(he=0;he<je.length;++he)r[je[he]]=ue[je[he]];c&&define(function(){return ue});}})();});var Ae=i=>`/xmtp/0/${i}/proto`,Fe=(i,e)=>{let t=[utils.getAddress(i),utils.getAddress(e)];return t.sort(),Ae(`dm-${t.join("-")}`)},et=i=>Ae(`m-${i}`),tt=i=>Ae(`contact-${utils.getAddress(i)}`),ne=i=>Ae(`intro-${utils.getAddress(i)}`),ge=i=>Ae(`invite-${utils.getAddress(i)}`),Dr=i=>Ae(`privatestore-${i}`);var fr=i=>new Promise(e=>setTimeout(e,i));var Ui=i=>!!i;async function rt(i,e,t,r,s=Ui,o=1){let a=typeof o=="number"?o:1;try{return await i(...e)}catch(c){if(!s(c)||a>t)throw c;return await fr(r),rt(i,e,t,r,s,a+1)}}async function*Ur(i,e){for await(let t of i){let r=await Promise.allSettled(t.map(e)),s=[];for(let o of r)o.status==="fulfilled"?s.push(o.value):console.warn("Failed to process envelope due to reason: ",o.reason);yield s;}}function N(i){return wn.fromNumber(i.valueOf()).multiply(1e6)}function X(i){return new Date(i.divide(1e6).toNumber())}var ie=i=>i&&N(i).toString(),Ii=i=>{if(i)return X(wn.fromString(i))};var{b64Decode:se,b64Encode:Ys}=fetcher;function Ir(i,e){let t=new Uint8Array(i.length+e.length);return t.set(i),t.set(e,i.length),t}var V=class{topics;client;messages;resolvers;callback;unsubscribeFn;constructor(e,t,r,s){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(r,s);}newMessageCallback(e,t){return async r=>{if(r.message)try{let s=await e(r);if(!s)return;if(t){let a=t(s);a&&this.resubscribeToTopics(a);}let o=this.resolvers.pop();o?o({value:s}):this.messages.unshift(s);}catch(s){console.warn(s);}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.unsubscribeFn=this.client.apiClient.subscribe({contentTopics:this.topics},async e=>{this.callback&&await this?.callback(e);});}static async create(e,t,r,s){let o=new V(e,t,r,s);return await o.start(),o}[Symbol.asyncIterator](){return this}async return(){return this.unsubscribeFn&&await this.unsubscribeFn(),this.callback?(this.callback=void 0,this.resolvers.forEach(e=>e({value:void 0,done:!0})),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){let e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise(t=>this.resolvers.unshift(t)):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.unsubscribeFn)throw new Error("Missing callback for stream");await this.unsubscribeFn(),this.topics=e,this.unsubscribeFn=this.client.apiClient.subscribe({contentTopics:this.topics},async t=>{this.callback&&await this?.callback(t);});}};var Nr=32,Rr=12,Ri=16,T=class{aes256GcmHkdfSha256;constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<Ri)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(e.aes256GcmHkdfSha256.hkdfSalt.length!==Nr)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(e.aes256GcmHkdfSha256.gcmNonce.length!==Rr)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256;}toBytes(){return ciphertext.Ciphertext.encode(this).finish()}static fromBytes(e){return new T(ciphertext.Ciphertext.decode(e))}};var Cn=vn(Kn(),1),Vi=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,Oi=Vi??Cn.webcrypto,k=Oi;var _i=new ArrayBuffer(0);async function M(i){return new Uint8Array(await k.subtle.digest("SHA-256",i))}async function W(i,e,t){let r=k.getRandomValues(new Uint8Array(Nr)),s=k.getRandomValues(new Uint8Array(Rr)),o=await An(e,r),a=await k.subtle.encrypt(En(s,t),o,i);return new T({aes256GcmHkdfSha256:{payload:new Uint8Array(a),hkdfSalt:r,gcmNonce:s}})}async function _(i,e,t){if(!i.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");let r=await An(e,i.aes256GcmHkdfSha256.hkdfSalt),s=await k.subtle.decrypt(En(i.aes256GcmHkdfSha256.gcmNonce,t),r,i.aes256GcmHkdfSha256.payload);return new Uint8Array(s)}function En(i,e){let t={name:"AES-GCM",iv:i};return e&&(t.additionalData=e),t}async function An(i,e){let t=await k.subtle.importKey("raw",i,"HKDF",!1,["deriveKey"]);return k.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:e,info:_i},t,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}var F=Q.utils.bytesToHex;function L(i){i.startsWith("0x")&&(i=i.slice(2));let e=new Uint8Array(i.length/2);for(let t=0;t<e.length;t++){let r=t*2;e[t]=Number.parseInt(i.slice(r,r+2),16);}return e}function Le(i,e){if(i.length!==e.length)return !1;for(let t=0;t<i.length;t++)if(i[t]!==e[t])return !1;return !0}function Sn(i){if(i.bytes.length!==32)throw new Error(`invalid private key length: ${i.bytes.length}`)}var U=class{createdNs;secp256k1;publicKey;constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(Sn(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new E(e.publicKey);}static async generate(e){let t={bytes:Q.utils.randomPrivateKey()},r=wn.fromNumber(new Date().getTime()).mul(1e6),s=new j({secp256k1Uncompressed:{bytes:Q.getPublicKey(t.bytes)},createdNs:r}),o=await e.signKey(s);return new U({secp256k1:t,createdNs:r,publicKey:o})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){let[t,r]=await Q.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new A({ecdsaCompact:{bytes:t,recovery:r}})}async signKey(e){let t=e.toBytes(),r=await M(t),s=await this.sign(r);return new E({keyBytes:t,signature:s})}static async signerKey(e,t){let r=await M(e.bytesToSign());return Vr(r,t)}sharedSecret(e){return Q.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,r){let s=this.sharedSecret(t);return W(e,s,r)}decrypt(e,t,r){let s=this.sharedSecret(t);return _(e,s,r)}matches(e){return this.publicKey.equals(e)}equals(e){return Le(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return privateKey.SignedPrivateKey.encode(this).finish()}static fromBytes(e){return new U(privateKey.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new U({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:E.fromLegacyKey(e.publicKey,t)})}},G=class{timestamp;secp256k1;publicKey;constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(Sn(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new D(e.publicKey);}static generate(){let e={bytes:Q.utils.randomPrivateKey()},t=wn.fromNumber(new Date().getTime());return new G({secp256k1:e,timestamp:t,publicKey:new D({secp256k1Uncompressed:{bytes:Q.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){let[t,r]=await Q.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new A({ecdsaCompact:{bytes:t,recovery:r}})}async signKey(e){let t=await M(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return Q.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,r){let s=this.sharedSecret(t);return W(e,s,r)}decrypt(e,t,r){let s=this.sharedSecret(t);return _(e,s,r)}matches(e){return this.publicKey.equals(e)}toBytes(){return privateKey.PrivateKey.encode(this).finish()}static fromBytes(e){return new G(privateKey.PrivateKey.decode(e))}};function Mn(i){if(i.bytes.length!==64)throw new Error(`invalid signature length: ${i.bytes.length}`);if(i.recovery!==0&&i.recovery!==1)throw new Error(`invalid recovery bit: ${i.recovery}`)}function Dn(i,e){return i.recovery===e.recovery&&Le(i.bytes,e.bytes)}function Vr(i,e){let t=Q.recoverPublicKey(i,e.bytes,e.recovery);return t?new j({secp256k1Uncompressed:{bytes:t},createdNs:wn.fromNumber(0)}):void 0}var A=class{ecdsaCompact;walletEcdsaCompact;constructor(e){if(e.ecdsaCompact)Mn(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else if(e.walletEcdsaCompact)Mn(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact;else throw new Error("invalid signature")}async signerKey(e){return this.ecdsaCompact?U.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?Z.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=Q.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else if(this.walletEcdsaCompact)t=Q.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery);else throw new Error("invalid v1 signature");return t?new D({secp256k1Uncompressed:{bytes:t},timestamp:wn.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Dn(this.ecdsaCompact,e.ecdsaCompact):this.walletEcdsaCompact&&e.walletEcdsaCompact?Dn(this.walletEcdsaCompact,e.walletEcdsaCompact):!1}toBytes(){return signature.Signature.encode(this).finish()}static fromBytes(e){return new A(signature.Signature.decode(e))}};var Z=class{wallet;constructor(e){this.wallet=e;}static identitySigRequestText(e){return `XMTP : Create Identity
${F(e)}

For more info: https://xmtp.org/signatures/`}static signerKey(e,t){let r=L(utils.hashMessage(this.identitySigRequestText(e.bytesToSign())));return Vr(r,t)}async signKey(e){let t=e.toBytes(),r=await this.wallet.signMessage(Z.identitySigRequestText(t)),s=utils.splitSignature(r),o=L(s.r),a=L(s.s),c=new Uint8Array(64);c.set(o),c.set(a,o.length);let p=new A({walletEcdsaCompact:{bytes:c,recovery:s.recoveryParam}});return new E({keyBytes:t,signature:p})}};function Hi(i){if(i.bytes.length!==65)throw new Error(`invalid public key length: ${i.bytes.length}`);if(i.bytes[0]!==4)throw new Error(`unrecognized public key prefix: ${i.bytes[0]}`)}var qi=new wn(10**9).mul(10**9),j=class{createdNs;secp256k1Uncompressed;constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");Hi(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned();}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(qi)}get timestamp(){return (this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return e.ecdsaCompact?Q.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes):!1}async verifyKey(e){if(!e.signature)return !1;let t=await M(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return Le(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return utils.computeAddress(this.secp256k1Uncompressed.bytes)}toBytes(){return publicKey.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new j(publicKey.UnsignedPublicKey.decode(e))}},E=class extends j{keyBytes;signature;constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(publicKey.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new A(e.signature);}get unsignedKey(){return new j({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");let e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return publicKey.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new E(publicKey.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new A({ecdsaCompact:e.walletEcdsaCompact})),new D({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let r=e.signature;return t&&(r=new A({walletEcdsaCompact:r.ecdsaCompact})),new E({keyBytes:e.bytesToSign(),signature:r})}},D=class extends j{signature;constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new A({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new A(e.signature));}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return publicKey.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){let t=await e.signMessage(Z.identitySigRequestText(this.bytesToSign())),r=utils.splitSignature(t),s=L(r.r),o=L(r.s),a=new Uint8Array(64);a.set(s),a.set(o,s.length),this.signature=new A({ecdsaCompact:{bytes:a,recovery:r.recoveryParam}});}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");let e=L(utils.hashMessage(Z.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return publicKey.PublicKey.encode(this).finish()}static fromBytes(e){return new D(publicKey.PublicKey.decode(e))}};var P=class{identityKey;preKey;constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new E(e.identityKey),this.preKey=new E(e.preKey);}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return publicKey.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new b({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){let t=publicKey.SignedPublicKeyBundle.decode(e);return new P(t)}static fromLegacyBundle(e){return new P({identityKey:E.fromLegacyKey(e.identityKey,!0),preKey:E.fromLegacyKey(e.preKey)})}},b=class{identityKey;preKey;constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new D(e.identityKey),this.preKey=new D(e.preKey);}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return publicKey.PublicKeyBundle.encode(this).finish()}static fromBytes(e){let t=publicKey.PublicKeyBundle.decode(e);return new b(t)}};var nt=class extends Error{constructor(e){super(`no pre-key matches: ${F(e.secp256k1Uncompressed.bytes)}`);}};var H=class{identityKey;preKeys;version=2;_publicKeyBundle;constructor(e){if(!e.identityKey)throw new Error("missing identity key");this.identityKey=new U(e.identityKey),this.preKeys=(e.preKeys||[]).map(t=>new U(t));}static async generate(e){let t=await U.generate(new Z(e)),r=new H({identityKey:t,preKeys:[]});return await r.addPreKey(),r}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){let t=this.preKeys.find(r=>r.matches(e));if(!t)throw new nt(e);return t}async addPreKey(){this._publicKeyBundle=void 0;let e=await U.generate(this.identityKey);this.preKeys.unshift(e);}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new P({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,r){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let s,o,a;r?(a=this.findPreKey(t),s=a.sharedSecret(e.identityKey),o=this.identityKey.sharedSecret(e.preKey)):(a=this.findPreKey(t),s=this.identityKey.sharedSecret(e.preKey),o=a.sharedSecret(e.identityKey));let c=a.sharedSecret(e.preKey),p=new Uint8Array(s.length+o.length+c.length);return p.set(s,0),p.set(o,s.length),p.set(c,s.length+o.length),p}encode(){return privateKey.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}equals(e){if(this.preKeys.length!==e.preKeys.length)return !1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return !1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new H({identityKey:U.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map(t=>U.fromLegacyKey(t))})}},Y=class{identityKey;preKeys;version=1;_publicKeyBundle;constructor(e){if(!e.identityKey)throw new Error("missing identity key");this.identityKey=new G(e.identityKey),this.preKeys=(e.preKeys||[]).map(t=>new G(t));}static async generate(e){let t=G.generate();e&&await t.publicKey.signWithWallet(e);let r=new Y({identityKey:t,preKeys:[]});return await r.addPreKey(),r}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){let t=this.preKeys.find(r=>r.matches(e));if(!t)throw new nt(e);return t}async addPreKey(){this._publicKeyBundle=void 0;let e=G.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e);}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new b({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,r){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let s,o,a;r?(a=this.findPreKey(t),s=a.sharedSecret(e.identityKey),o=this.identityKey.sharedSecret(e.preKey)):(a=this.findPreKey(t),s=this.identityKey.sharedSecret(e.preKey),o=a.sharedSecret(e.identityKey));let c=a.sharedSecret(e.preKey),p=new Uint8Array(s.length+o.length+c.length);return p.set(s,0),p.set(o,s.length),p.set(c,s.length+o.length),p}encode(){return privateKey.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}};function it(i){let e=privateKey.PrivateKeyBundle.decode(i);if(e.v1)return new Y(e.v1);if(e.v2)return new H(e.v2);throw new Error("unknown private key bundle version")}var zi=16,$i=65,Xi=32,Wi=16,Gi=i=>{if(i.iv.length!==zi)throw new Error("Invalid iv length");if(i.ephemeralPublicKey.length!==$i)throw new Error("Invalid ephemPublicKey length");if(i.ciphertext.length<1||i.ciphertext.length%Wi!==0)throw new Error("Invalid ciphertext length");if(i.mac.length!==Xi)throw new Error("Invalid mac length")},oe=class{eciesBytes;signature;ciphertext;constructor({eciesBytes:e,signature:t}){if(!e||!e.length)throw new Error("eciesBytes is empty");if(!t)throw new Error("signature is undefined");this.eciesBytes=e,this.signature=new A(t),this.ciphertext=ciphertext.SignedEciesCiphertext_Ecies.decode(e);}toBytes(){return ciphertext.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await M(this.eciesBytes))}static fromBytes(e){let t=ciphertext.SignedEciesCiphertext.decode(e);return new oe(t)}static async create(e,t){Gi(e);let r=ciphertext.SignedEciesCiphertext_Ecies.encode(e).finish(),s=await t.sign(await M(r));return new oe({eciesBytes:r,signature:s})}};var st=class{messageEnvelope;onSend;constructor(e,t){this.messageEnvelope=e,this.onSend=t;}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return F(await M(this.messageEnvelope.message))}async send(){await this.onSend();}};var x=class extends Error{code;constructor(e,t){super(t),this.code=e;}};var xe=i=>{if(i.error)throw new x(i.error.code,i.error.message);if(!i.result)throw new x(keystore.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in i.result&&!i.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in i.result&&!i.result.decrypted)throw new Error("Missing decrypted result");return i.result},br=(i,e)=>({requests:i.map(t=>{let r=new b({identityKey:t.header.sender?.identityKey,preKey:t.header.sender?.preKey}),s=e.equals(r);return {payload:t.ciphertext,peerKeys:s?new b({identityKey:t.header.recipient?.identityKey,preKey:t.header.recipient?.preKey}):r,headerBytes:t.headerBytes,isSender:s}})});var q=class{authorityId;typeId;versionMajor;versionMinor;constructor(e){this.authorityId=e.authorityId,this.typeId=e.typeId,this.versionMajor=e.versionMajor,this.versionMinor=e.versionMinor;}toString(){return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`}sameAs(e){return this.authorityId===e.authorityId&&this.typeId===e.typeId}},Fr=new q({authorityId:"xmtp.org",typeId:"fallback",versionMajor:1,versionMinor:0});var we=new q({authorityId:"xmtp.org",typeId:"text",versionMajor:1,versionMinor:0});var ot=class{get contentType(){return we}encode(e){return {type:we,parameters:{encoding:"UTF-8"},content:new TextEncoder().encode(e)}}decode(e){let t=e.parameters.encoding;if(t&&t!=="UTF-8")throw new Error(`unrecognized encoding ${t}`);return new TextDecoder().decode(e.content)}};var J=class{peerAddress;createdAt;context=void 0;client;constructor(e,t,r){this.peerAddress=utils.getAddress(t),this.client=e,this.createdAt=r;}get clientAddress(){return this.client.address}get topic(){return Fe(this.peerAddress,this.client.address)}get ephemeralTopic(){return Fe(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){let t=Fe(this.peerAddress,this.client.address),r=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(r,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");let t=await this.processEnvelope(e),r=await this.decryptBatch([t],e.contentTopic,!0);if(!r.length)throw new Error("No results");return r[0]}async prepareMessage(e,t){let r,s=await this.client.getUserContact(this.peerAddress);if(!s)throw new Error(`recipient ${this.peerAddress} is not registered`);s instanceof b||(s=s.toLegacyBundle()),this.client.contacts.has(this.peerAddress)?r=[this.topic]:(r=[ne(this.peerAddress),ne(this.client.address),this.topic],this.client.contacts.add(this.peerAddress));let o=await this.client.encodeContent(e,t),a=await this.createMessage(o,s,t?.timestamp),c={contentTopic:this.topic,message:a.toBytes(),timestampNs:ie(a.sent)};return new st(c,async()=>{await this.client.publishEnvelopes(r.map(p=>({contentTopic:p,message:a.toBytes(),timestamp:a.sent})));})}streamMessages(){return V.create(this.client,[this.topic],async e=>this.decodeMessage(e))}async processEnvelope({message:e,contentTopic:t}){let r=se(e),s=await O.fromBytes(r),{senderAddress:o,recipientAddress:a}=s;if(!o||!a||!t||Fe(o,a)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(){return V.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this))}async send(e,t){let r,s=await this.client.getUserContact(this.peerAddress);if(!s)throw new Error(`recipient ${this.peerAddress} is not registered`);s instanceof b||(s=s.toLegacyBundle());let o=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.has(this.peerAddress)?r=[this.topic]:(r=[ne(this.peerAddress),ne(this.client.address),o],this.client.contacts.add(this.peerAddress));let a=t?.contentType||we,c=await this.client.encodeContent(e,t),p=await this.createMessage(c,s,t?.timestamp);return await this.client.publishEnvelopes(r.map(y=>({contentTopic:y,message:p.toBytes(),timestamp:p.sent}))),R.fromV1Message(p,e,a,c,r[0],this)}async decryptBatch(e,t,r=!1){let s=(await this.client.keystore.decryptV1(br(e,this.client.publicKeyBundle))).responses,o=[];for(let a=0;a<s.length;a++){let c=s[a],p=e[a];try{let{decrypted:y}=xe(c);o.push(await this.buildDecodedMessage(p,y,t));}catch(y){if(r)throw y;console.warn("Error decoding content",y);}}return o}async buildDecodedMessage(e,t,r){let{content:s,contentType:o,error:a}=await at(t,this.client);return R.fromV1Message(e,s,o,t,r,this,a)}async createMessage(e,t,r){return r=r||new Date,O.encode(this.client.keystore,e,this.client.publicKeyBundle,t,r)}},ae=class{client;topic;peerAddress;createdAt;context;constructor(e,t,r,s,o){this.topic=t,this.createdAt=s,this.context=o,this.client=e,this.peerAddress=r;}get clientAddress(){return this.client.address}async messages(e){let t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(){return V.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this))}streamMessages(){return V.create(this.client,[this.topic],this.decodeMessage.bind(this))}async send(e,t){let r=await this.client.encodeContent(e,t),s=await this.createMessage(r,t?.timestamp),o;t?.ephemeral?o=this.ephemeralTopic:o=this.topic,await this.client.publishEnvelopes([{contentTopic:o,message:s.toBytes(),timestamp:s.sent}]);let a=t?.contentType||we;return R.fromV2Message(s,e,a,this.topic,r,this,this.client.address)}async createMessage(e,t){let r={topic:this.topic,createdNs:N(t||new Date)},s=message.MessageHeaderV2.encode(r).finish(),o=await M(Ir(s,e)),a={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:o,prekeyIndex:0,identityKey:void 0})},c=content.SignedContent.encode(a).finish(),p=await this.encryptMessage(c,s),y={v1:void 0,v2:{headerBytes:s,ciphertext:p}},f=message.Message.encode(y).finish();return be.create(y,r,f)}async decryptBatch(e,t=!1){let r=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,s=[];for(let o=0;o<r.length;o++){let a=r[o],c=e[o];try{let{decrypted:p}=xe(a);s.push(await this.buildDecodedMessage(c,p));}catch(p){if(t)throw p;console.warn("Error decoding content",p);}}return s}buildDecryptRequest(e){return {requests:e.map(t=>({payload:t.ciphertext,headerBytes:t.headerBytes,contentTopic:this.topic}))}}async encryptMessage(e,t){let{responses:r}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(r.length!==1)throw new Error("Invalid response length");let{encrypted:s}=xe(r[0]);return s}async buildDecodedMessage(e,t){let r=content.SignedContent.decode(t);if(!r.sender?.identityKey||!r.sender?.preKey||!r.signature)throw new Error("incomplete signed content");await Yi(r);let s=await M(Ir(e.headerBytes,r.payload));if(!new E(r.sender?.preKey).verify(new A(r.signature),s))throw new Error("invalid signature");let o=await new P(r.sender).walletSignatureAddress(),{content:a,contentType:c,error:p}=await at(r.payload,this.client);return R.fromV2Message(e,a,c,this.topic,r.payload,this,o,p)}async prepareMessage(e,t){let r=await this.client.encodeContent(e,t),s=await this.createMessage(r,t?.timestamp),a={contentTopic:t?.ephemeral?this.ephemeralTopic:this.topic,message:s.toBytes(),timestampNs:ie(s.sent)};return new st(a,async()=>{await this.client.publishEnvelopes([{contentTopic:this.topic,message:s.toBytes(),timestamp:s.sent}]);})}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");let t=se(e.message.toString()),r=message.Message.decode(t);if(!r.v2)throw new Error("unknown message version");let s=message.MessageHeaderV2.decode(r.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return be.create(r,s,t)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");let t=await this.processEnvelope(e),r=await this.decryptBatch([t],!0);if(!r.length)throw new Error("No results");return r[0]}};async function Yi(i){let e=i.sender?.preKey;if(!e||!e.signature||!e.keyBytes)throw new Error("missing pre-key or pre-key signature");let t=i.sender?.identityKey;if(!t)throw new Error("missing identity key in bundle");if(!await new E(t).verifyKey(new E(e)))throw new Error("pre key not signed by identity key")}async function Vn(i,e){if(i.compression===void 0)return;let t={bytes:new Uint8Array(i.content.length)};await Fn(i.content).pipeThrough(new DecompressionStream(_n(i.compression))).pipeTo(Ln(t,e)),i.content=t.bytes;}async function On(i){if(i.compression===void 0)return;let e={bytes:new Uint8Array(i.content.length/10)};await Fn(i.content).pipeThrough(new CompressionStream(_n(i.compression))).pipeTo(Ln(e,i.content.length+1e3)),i.content=e.bytes;}function _n(i){if(i===content.Compression.COMPRESSION_GZIP)return "gzip";if(i===content.Compression.COMPRESSION_DEFLATE)return "deflate";throw new Error("unrecognized compression algorithm")}function Fn(i,e=1024){let t=0;return new ReadableStream({pull(r){if(t>=i.length)return r.close();let s=t+e;s=s<=i.length?s:i.length,r.enqueue(i.subarray(t,s)),t=s;}})}function Ln(i,e){let t=0;return new WritableStream({write(r){let s=t+r.length;if(s>e)throw new Error("maximum output size exceeded");for(;i.bytes.length<s;)i.bytes=Ji(i.bytes,e);i.bytes.set(r,t),t=s;},close(){t<i.bytes.length&&(i.bytes=i.bytes.subarray(0,t));}})}function Ji(i,e){let t=i.length*2;t>e&&(t=e);let r=new Uint8Array(t);return r.set(i),r}var Hn=i=>{if(i.v1?.ciphertext)return [i.v1.headerBytes,new T(i.v1.ciphertext)];if(i.v2?.ciphertext)return [i.v2.headerBytes,new T(i.v2.ciphertext)];throw new Error("unknown message version")},Kr=class{headerBytes;ciphertext;contentType;error;id;bytes;constructor(e,t,r){[this.headerBytes,this.ciphertext]=Hn(r),this.id=e,this.bytes=t;}toBytes(){return this.bytes}},O=class extends Kr{header;senderAddress;conversation=void 0;constructor(e,t,r,s,o){super(e,t,r),this.senderAddress=o,this.header=s;}static async create(e,t,r){if(!t.sender)throw new Error("missing message sender");let s=new b(t.sender).walletSignatureAddress(),o=F(await M(r));return new O(o,r,e,t,s)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new D(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){let r=(await e.decryptV1(br([this],t))).responses;if(!r.length)throw new Error("No response from Keystore");let{decrypted:s}=xe(r[0]);return s}static fromBytes(e){let t=message.Message.decode(e),[r]=Hn(t),s=message.MessageHeaderV1.decode(r);if(!s)throw new Error("missing message header");if(!s.sender)throw new Error("missing message sender");if(!s.sender.identityKey)throw new Error("missing message sender identity key");if(!s.sender.preKey)throw new Error("missing message sender pre-key");if(!s.recipient)throw new Error("missing message recipient");if(!s.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!s.recipient.preKey)throw new Error("missing message recipient pre-key");return O.create(t,s,e)}static async encode(e,t,r,s,o){let a={sender:r,recipient:s,timestamp:wn.fromNumber(o.getTime())},c=message.MessageHeaderV1.encode(a).finish(),p=await e.encryptV1({requests:[{recipient:s,headerBytes:c,payload:t}]});if(!p.responses.length)throw new Error("No response from Keystore");let{encrypted:y}=xe(p.responses[0]),f={v1:{headerBytes:c,ciphertext:y},v2:void 0},K=message.Message.encode(f).finish();return O.create(f,a,K)}},be=class extends Kr{senderAddress;header;constructor(e,t,r,s){super(e,t,r),this.header=s;}static async create(e,t,r){let s=F(await M(r));return new be(s,r,e,t)}get sent(){return X(this.header.createdNs)}},R=class{id;messageVersion;senderAddress;recipientAddress;sent;contentTopic;conversation;contentType;content;error;contentBytes;constructor({id:e,messageVersion:t,senderAddress:r,recipientAddress:s,conversation:o,contentBytes:a,contentType:c,contentTopic:p,content:y,sent:f,error:K}){this.id=e,this.messageVersion=t,this.senderAddress=r,this.recipientAddress=s,this.conversation=o,this.contentType=c,this.sent=f,this.error=K,this.content=y,this.contentTopic=p,this.contentBytes=a;}toBytes(){return message.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:N(this.conversation.createdAt),peerAddress:this.conversation.peerAddress},sentNs:N(this.sent)}).finish()}static async fromBytes(e,t){let r=message.DecodedMessage.decode(e),s=r.messageVersion;if(s!=="v1"&&s!=="v2")throw new Error("Invalid message version");if(!r.conversation)throw new Error("No conversation reference found");let{content:o,contentType:a,error:c}=await at(r.contentBytes,t);return new R({...r,content:o,contentType:a,error:c,messageVersion:s,sent:X(r.sentNs),conversation:ts(r.conversation,t,s)})}static fromV1Message(e,t,r,s,o,a,c){let{id:p,senderAddress:y,recipientAddress:f,sent:K}=e;if(!y)throw new Error("Sender address is required");return new R({id:p,messageVersion:"v1",senderAddress:y,recipientAddress:f,sent:K,content:t,contentBytes:s,contentType:r,contentTopic:o,conversation:a,error:c})}static fromV2Message(e,t,r,s,o,a,c,p){let{id:y,sent:f}=e;return new R({id:y,messageVersion:"v2",senderAddress:c,sent:f,content:t,contentBytes:o,contentType:r,contentTopic:s,conversation:a,error:p})}};async function at(i,e){let t=content.EncodedContent.decode(i);if(!t.type)throw new Error("missing content type");let r,s=new q(t.type),o;await Vn(t,1e3);let a=e.codecFor(s);return a?r=a.decode(t,e):(o=new Error("unknown content type "+s),t.fallback&&(r=t.fallback,s=Fr)),{content:r,contentType:s,error:o}}function ts(i,e,t){if(t==="v1")return new J(e,i.peerAddress,X(i.createdNs));if(t==="v2")return new ae(e,i.topic,i.peerAddress,X(i.createdNs),i.context);throw new Error(`Unknown conversation version ${t}`)}var rs=60*60-10,ct=class{authenticator;token;maxAgeMs;constructor(e,t=rs){this.authenticator=e,this.maxAgeMs=t*1e3;}async getToken(){return (!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken();}};var qn={name:"@xmtp/xmtp-js",version:"9.1.6",description:"XMTP client SDK for interacting with XMTP networks.",type:"module",main:"dist/index.cjs",module:"dist/index.js",types:"dist/index.d.ts",browser:"dist/web/index.js",exports:{".":{types:"./dist/index.d.ts",browser:"./dist/web/index.js",import:"./dist/index.js",require:"./dist/index.cjs"}},scripts:{prebench:"npm run build:bench",bench:"node dist/bench/index.cjs",build:"npm run clean:dist && npm run build:node && npm run build:web","build:bench":"tsup --out-dir dist/bench --entry.0 bench/index.ts --format cjs","build:node":"tsup","build:web":"tsup --platform browser --target esnext","build:docs":"rimraf docs && mkdir -p tmp && cp README.md tmp/ && sed -i.bak '/badge.svg/d' tmp/README.md && typedoc --excludePrivate --readme tmp/README.md src/index.ts",clean:"npm run clean:dist && npm run clean:proto","clean:dist":"rimraf dist","clean:proto":"rimraf -g src/proto/*.ts",package:"npm pack",prepublishOnly:"npm run build","test:setup":"./dev/up","test:teardown":"./dev/down",test:"npm run test:node","test:node":"jest --no-cache --env='node' --testTimeout=30000","test:jsdom":"jest --no-cache --env='./jest.jsdom.env.cjs' --testTimeout=30000","test:cov":"jest --coverage --no-cache --runInBand",lint:"prettier --check . && eslint .",autolint:"prettier --write . && eslint --fix .","semantic-release":"semantic-release"},publishConfig:{access:"public",provenance:!0},files:["dist/index.cjs","dist/index.cjs.map","dist/index.d.ts","dist/index.js","dist/index.js.map","dist/web/index.js","dist/web/index.js.map"],keywords:["xmtp","messaging","web3","sdk","js","javascript","node","nodejs"],author:"XMTP Labs <eng@xmtp.com>",license:"MIT",homepage:"https://github.com/xmtp/xmtp-js",repository:{type:"git",url:"https:git@github.com:xmtp/xmtp-js.git"},bugs:{url:"https://github.com/xmtp/xmtp-js/issues"},release:{branches:["main",{name:"beta",prerelease:!0}]},dependencies:{"@noble/secp256k1":"^1.5.2","@xmtp/proto":"^3.24.0","async-mutex":"^0.4.0",elliptic:"^6.5.4",ethers:"^5.5.3",long:"^5.2.0"},devDependencies:{"@commitlint/cli":"^16.1.0","@commitlint/config-conventional":"^16.0.0","@types/benchmark":"^2.1.2","@types/bl":"^5.0.2","@types/callback-to-async-iterator":"^1.1.4","@types/elliptic":"^6.4.14","@types/jest":"^28.1.3","@types/node":"^18.14.0","@typescript-eslint/eslint-plugin":"^5.38.0","@typescript-eslint/parser":"^5.38.0",benny:"^3.7.1","dd-trace":"^2.12.2",esbuild:"^0.17.16","esbuild-plugin-external-global":"^1.0.1",eslint:"^8.0.1","eslint-config-prettier":"^8.3.0","eslint-config-standard":"^17.0.0","eslint-plugin-import":"^2.26.0","eslint-plugin-jsdoc":"^37.9.1","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.0.0","eslint-plugin-promise":"^6.0.1",husky:"^7.0.4",jest:"^28.1.3","jest-environment-jsdom":"^28.1.3",prettier:"^2.4.0",rimraf:"^5.0.0","semantic-release":"^21.0.3","ts-jest":"^28.0.0","ts-node":"^10.9.1",tsup:"^6.7.0",typedoc:"^0.22.11",typescript:"^4.4.3"},engines:{node:">=18"}};var zn=`
XX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV 
 XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV 
  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  
 XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   
XX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    

Connected to the XMTP 'dev' network. Use 'production' for production messages.
https://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments
`;var {MessageApi:Cr,SortDirection:ye}=messageApi,Lr=100,ss=16,os="X-Client-Version",as="X-App-Version",pt={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var qe=class extends Error{code;constructor(e,t){super(e),this.code=t;}static fromObject(e){return new qe(e.message,e.code)}},cs=i=>i?!!(i.name==="AbortError"||i.message.includes("aborted")):!1,ps=i=>!!(i&&"code"in i&&i.code===ss),$n=i=>!ps(i),Be=class{pathPrefix;maxRetries;authCache;appVersion;version;constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/"+qn.version,e===pt.dev&&console.info(zn);}async _query(e){try{return await rt(Cr.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,Lr)}catch(t){throw qe.fromObject(t)}}_batchQuery(e){return rt(Cr.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,Lr)}async _publish(e,t=0){let r=await this.getToken(),s=this.headers();s.set("Authorization",`Bearer ${r}`);try{return await rt(Cr.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:s}],this.maxRetries,Lr,$n)}catch(o){if($n(o)||t>=1)throw qe.fromObject(o);return await this.authCache?.refresh(),this._publish(e,t+1)}}_subscribe(e,t){let r=new AbortController;return (async()=>{for(;;){let o=new Date().getTime();try{if(await Cr.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:r.signal,mode:"cors",headers:this.headers()}),r.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),new Date().getTime()-o<1e3&&await fr(1e3);}catch(a){if(cs(a)||r.signal.aborted)return;console.info("Stream connection closed. Resubscribing",a.toString()),new Date().getTime()-o<1e3&&await fr(1e3);}}})(),async()=>{r?.abort();}}async query(e,{direction:t=ye.SORT_DIRECTION_ASCENDING,limit:r}){let s=[];for await(let o of this.queryIteratePages(e,{direction:t,pageSize:r&&r<100?r:100}))for(let a of o)if(s.push(a),r&&s.length===r)return s;return s}async*queryIterator(e,t){for await(let r of this.queryIteratePages(e,t))for(let s of r)yield s;}async*queryIteratePages({contentTopic:e,startTime:t,endTime:r},{direction:s,pageSize:o=10}){if(!e||!e.length)throw new Error("Must specify content topics");let a=ie(t),c=ie(r),p;for(;;){let y={limit:o,direction:s,cursor:p},f=await this._query({contentTopics:[e],startTimeNs:a,endTimeNs:c,pagingInfo:y});if(f.envelopes?.length)yield f.envelopes;else return;if(f.pagingInfo?.cursor)p=f.pagingInfo?.cursor;else return}}async batchQuery(e){let r=[];for(let a=0;a<e.length;a+=50){let c=e.slice(a,a+50),p=[];for(let f of c)p.push({contentTopics:[f.contentTopic],startTimeNs:ie(f.startTime),endTimeNs:ie(f.endTime),pagingInfo:{limit:f.pageSize||10,direction:f.direction||ye.SORT_DIRECTION_ASCENDING}});let y={requests:p};r.push(y);}let s=await Promise.all(r.map(async a=>this._batchQuery(a))),o=[];for(let a of s){if(!a.responses)throw new Error("BatchQueryResponse missing responses");for(let c of a.responses)c.envelopes?o.push(c.envelopes):o.push([]);}return o}async publish(e){let t=[];for(let{contentTopic:r,message:s,timestamp:o}of e){if(!r.length)throw new Error("Content topic cannot be empty string");if(!s.length)throw new Error("0 length messages not allowed");let a=o||new Date;t.push({contentTopic:r,timestampNs:ie(a),message:Uint8Array.from(s)});}return this._publish({envelopes:t})}subscribe(e,t){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,t)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new ct(e,t);}headers(){let e=new Headers;return e.set(os,this.version),this.appVersion&&e.set(as,this.appVersion),e}};var Xn=1e4,Wn=i=>!!(i.recipientAddress&&i.senderAddress),Hr=class{conversations;mutex;latestSeen;seenTopics;constructor(){this.conversations=[],this.mutex=new Mutex,this.seenTopics=new Set;}async load(e){let t=await this.mutex.acquire();try{let r=await e({latestSeen:this.latestSeen,existing:this.conversations});for(let s of r)this.seenTopics.has(s.topic)||(this.seenTopics.add(s.topic),this.conversations.push(s),(!this.latestSeen||s.createdAt>this.latestSeen)&&(this.latestSeen=s.createdAt));}finally{t();}return [...this.conversations]}},Se=class{client;v1Cache;v2Mutex;constructor(e){this.client=e,this.v1Cache=new Hr,this.v2Mutex=new Mutex;}async list(){let[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),r=e.concat(t);return r.sort((s,o)=>s.createdAt.getTime()-o.createdAt.getTime()),r}async listV1Conversations(){return this.v1Cache.load(async({latestSeen:e})=>{let t=await this.getIntroductionPeers({startTime:e?new Date(+e-Xn):void 0,direction:ye.SORT_DIRECTION_ASCENDING});return Array.from(t).map(([r,s])=>new J(this.client,r,s))})}async listV2Conversations(){return this.v2Mutex.runExclusive(async()=>{let e=await this.getV2ConversationsFromKeystore(),t=e.reduce((o,a)=>!o||+a.createdAt>+o.createdAt?a:o,void 0),r=await this.updateV2Conversations(t?.createdAt),s=new Set(e.map(o=>o.topic));for(let o of r)s.has(o.topic)||(e.push(o),s.add(o.topic));return e.sort((o,a)=>o.createdAt.getTime()-a.createdAt.getTime()),e})}async getV2ConversationsFromKeystore(){return (await this.client.keystore.getV2Conversations()).map(this.conversationReferenceToV2.bind(this))}async updateV2Conversations(e){let t=await this.client.listInvitations({startTime:e?new Date(+e-Xn):void 0,direction:ye.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){let{responses:r}=await this.client.keystore.saveInvites({requests:e.map(o=>({payload:se(o.message),timestampNs:wn.fromString(o.timestampNs),contentTopic:o.contentTopic}))}),s=[];for(let o of r)try{let a=this.saveInviteResponseToConversation(o);s.push(a);}catch(a){if(console.warn("Error saving invite response to conversation: ",a),t)throw a}return s}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new ae(this.client,e.topic,e.peerAddress,X(e.createdNs),e.context)}async stream(){let e=new Set,t=ne(this.client.address),r=ge(this.client.address),s=a=>e.has(a)?!1:(e.add(a),!0),o=async a=>{if(a.contentTopic===t){let c=se(a.message),p=await O.fromBytes(c),y=this.getPeerAddress(p);return s(y)?(await p.decrypt(this.client.keystore,this.client.publicKeyBundle),new J(this.client,y,p.sent)):void 0}if(a.contentTopic===r){let c=await this.decodeInvites([a],!0);if(c.length)return c[0]}throw new Error("unrecognized invite topic")};return V.create(this.client,[r,t],o.bind(this))}async streamAllMessages(){let e=ne(this.client.address),t=ge(this.client.address),r=new Set([e,t]),s=new Map;for(let y of await this.list())r.add(y.topic),s.set(y.topic,y);let o=async y=>{let f=y.contentTopic;if(!f)return null;if(f===e){let me=se(y.message),fe=await O.fromBytes(me);if(!Wn(fe))return null;let I=this.getPeerAddress(fe);return new J(this.client,I,fe.sent).decodeMessage(y)}if(f===t)return (await this.decodeInvites([y],!0))[0];let K=s.get(f);if(K instanceof J||K instanceof ae)return K.decodeMessage(y);throw console.log("Unknown topic"),new Error("Unknown topic")},a=(y,f)=>r.has(y)?!1:(s.set(y,f),r.add(y),!0),c=y=>{if(y instanceof R&&y.contentTopic===e){let f=new J(this.client,y.recipientAddress===this.client.address?y.senderAddress:y.recipientAddress,y.sent);return a(f.topic,f)?Array.from(r.values()):void 0}if(y instanceof ae)return a(y.topic,y)?Array.from(r.values()):void 0},p=await V.create(this.client,Array.from(r.values()),o,c);return async function*(){for await(let f of p)if(f instanceof R&&(yield f),f instanceof ae)for(let K of await f.messages())yield K;}()}async getIntroductionPeers(e){let t=ne(this.client.address),r=await this.client.listEnvelopes(t,o=>O.fromBytes(se(o.message)),e),s=new Map;for(let o of r){if(!Wn(o))continue;let a=this.getPeerAddress(o);if(a){let c=s.get(a);if(!c||c>o.sent)try{await o.decrypt(this.client.keystore,this.client.publicKeyBundle),s.set(a,o.sent);}catch{continue}}}return s}async newConversation(e,t){let r=await this.client.getUserContact(e);if(!r)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e===this.client.address)throw new Error("self messaging not supported");if(r instanceof b&&!t?.conversationId)return new J(this.client,e,new Date);if(!t?.conversationId){let a=(await this.listV1Conversations()).find(c=>c.peerAddress===e);if(a){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(r instanceof b)&&!r.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return a}}r instanceof b&&(r=P.fromLegacyBundle(r));let s=o=>o.peerAddress===e&&us(t,o.context??void 0);return this.v2Mutex.runExclusive(async()=>{let o=await this.getV2ConversationsFromKeystore(),a=o.find(s);if(a)return a;let c=o[o.length-1]?.createdAt,y=(await this.updateV2Conversations(c)).find(s);return y||this.createV2Convo(r,t)})}async createV2Convo(e,t){let r=new Date,{payload:s,conversation:o}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:N(r)});if(!s||!o)throw new Error("Required field not returned from Keystore");let a=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:ge(a),message:s,timestamp:r},{contentTopic:ge(this.client.address),message:s,timestamp:r}]),this.conversationReferenceToV2(o)}getPeerAddress(e){return e.recipientAddress===this.client.address?e.senderAddress:e.recipientAddress}};function us(i,e){return i?.conversationId===e?.conversationId}function Er(i){let e;try{e=contact.ContactBundle.decode(i);}catch{let r=publicKey.PublicKeyBundle.decode(i);e={v1:{keyBundle:new b(r)},v2:void 0};}if(e.v1?.keyBundle)return new b(e.v1.keyBundle);if(e.v2?.keyBundle)return new P(e.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function Qn(i){return i instanceof b?contact.ContactBundle.encode({v1:{keyBundle:i},v2:void 0}).finish():contact.ContactBundle.encode({v1:void 0,v2:{keyBundle:i}}).finish()}var Zn=vn(jn(),1);var ee=class{walletAddr;createdNs;constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t;}static create(e,t){return t=t||new Date,new ee({walletAddr:e,createdNs:N(t)})}static fromBytes(e){let t=authn.AuthData.decode(e);return new ee(t)}toBytes(){return authn.AuthData.encode(this).finish()}};var te=class{identityKey;authDataBytes;authDataSignature;_authData;constructor({identityKey:e,authDataBytes:t,authDataSignature:r}){if(!e)throw new Error("Missing identity key in token");if(!r)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=r;}get authData(){return this._authData||(this._authData=ee.fromBytes(this.authDataBytes)),this._authData}get ageMs(){let e=new Date().valueOf(),r=this.authData.createdNs.div(1e6).toNumber();return e-r}toBytes(){return authn.Token.encode(this).finish()}static fromBytes(e){return new te(authn.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}};var Pe=class{identityKey;constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e;}async createToken(e){let r=ee.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),s=(0, Zn.keccak256)(r),o=await this.identityKey.sign(L(s));return new te(authn.Token.fromPartial({identityKey:publicKey.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:r,authDataSignature:signature.Signature.fromPartial(o)}))}};var hs=i=>i instanceof te?i:new te(i),ze=class{keystore;constructor(e){this.keystore=e;}async createToken(e){let t=await this.keystore.createAuthToken({timestampNs:e?N(e):void 0});return hs(t)}};var ei=0,$e=class{configuration;static createConfiguration(){return {type:ei,version:0}}constructor(e){this.configuration=e;}get backupType(){return ei}};var ti=1,Xe=class{configuration;static createConfiguration(e){return {type:ti,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e;}get backupType(){return ti}};async function ri(i,e){let t=await gs(i,e);switch(t.type){case 0:return new $e(t);case 1:return new Xe(t)}}async function gs(i,e){let t;switch((await e()).type){case 0:t=$e.createConfiguration();break;case 1:t=Xe.createConfiguration(i);break}return t}var re=class extends Error{};var {b64Decode:bs}=fetcher,Ce=class{topic;context;aes256GcmHkdfSha256;constructor({topic:e,context:t,aes256GcmHkdfSha256:r}){if(!e||!e.length)throw new Error("Missing topic");if(!r||!r.keyMaterial||!r.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=r;}static createRandom(e){let t=et(Buffer.from(k.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace("/","-")),r=k.getRandomValues(new Uint8Array(32));return new Ce({topic:t,aes256GcmHkdfSha256:{keyMaterial:r},context:e})}toBytes(){return invitation.InvitationV1.encode(this).finish()}static fromBytes(e){return new Ce(invitation.InvitationV1.decode(e))}},We=class{sender;recipient;createdNs;constructor({sender:e,recipient:t,createdNs:r}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new P(e),this.recipient=new P(t),this.createdNs=r;}toBytes(){return invitation.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new We(invitation.SealedInvitationHeaderV1.decode(e))}},dt=class{headerBytes;ciphertext;_header;_invitation;constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new T(t);}get header(){return this._header?this._header:(this._header=We.fromBytes(this.headerBytes),this._header)}async getInvitation(e){if(this._invitation)return this._invitation;let t=this.header,r;e.identityKey.matches(this.header.sender.identityKey)?r=await e.sharedSecret(t.recipient,t.sender.preKey,!1):r=await e.sharedSecret(t.sender,t.recipient.preKey,!0);let s=await _(this.ciphertext,r,this.headerBytes);return this._invitation=Ce.fromBytes(s),this._invitation}toBytes(){return invitation.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new dt(invitation.SealedInvitationV1.decode(e))}},ce=class{v1;constructor({v1:e}){if(e)this.v1=new dt(e);else throw new Error("Missing v1 or v2 invitation")}toBytes(){return invitation.SealedInvitation.encode(this).finish()}static fromBytes(e){return new ce(invitation.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");let t=ce.fromBytes(bs(e.message)),r=wn.fromString(e.timestampNs),s=t.v1?.header.createdNs;if(!s||!s.equals(r))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:r,invitation:s}){let o=new We({sender:e.getPublicKeyBundle(),recipient:t,createdNs:N(r)}).toBytes(),a=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),c=s.toBytes(),p=await W(c,a,o);return new ce({v1:{headerBytes:o,ciphertext:p}})}};var ni=async(i,e,t,r,s)=>{let o=await i.sharedSecret(e,i.getCurrentPreKey().publicKey,!s);return _(t,o,r)},ii=async(i,e,t,r)=>{let s=await i.sharedSecret(e,i.getCurrentPreKey().publicKey,!1);return W(t,s,r)},si=(i,e,t)=>_(i,e,t),oi=(i,e,t)=>W(i,e,t);var Xr=(i,e)=>i instanceof x?i:new x(e,i.message),Ps=i=>({result:i}),Ge=(i,e,t)=>Promise.all(i.map(async r=>{try{return Ps(await e(r))}catch(s){return {error:Xr(s,t)}}})),Wr=i=>i instanceof b?i:new b(i),ai=i=>i instanceof P?i:new P(i),ke=(i,e,t)=>{for(let r of e)if(!i[r])throw new x(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(r)}`);for(let r of t){let s=i[r];if(!s||!s?.length)throw new x(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(r)}`)}return !0},Gr=i=>{if(!i?.aes256GcmHkdfSha256?.keyMaterial)throw new x(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return i.aes256GcmHkdfSha256.keyMaterial},xr=({invitation:i,createdNs:e,peerAddress:t})=>({context:i.context,topic:i.topic,peerAddress:t,createdNs:e}),Ks=i=>!!i.invitation,ci=i=>{let e={};for(let[t,r]of Object.entries(i.topics))Ks(r)?e[t]=r:console.warn("Invitation missing from topic data");return e};var di="invitations/v1",le=class{persistence;mutex;topicMap;constructor(e,t=new Map){this.persistence=e,this.mutex=new Mutex,this.topicMap=t;}static async create(e){if(e){let t=await e.getItem(di);if(t)try{let r=ci(keystore.TopicMap.decode(t));return new le(e,new Map(Object.entries(r)))}catch(r){console.warn(`Error loading invites from store: ${r}`);}}return new le(e)}async add(e){await this.mutex.runExclusive(async()=>{let t=!1;for(let r of e)this.topicMap.has(r.invitation.topic)||(this.topicMap.set(r.invitation.topic,r),t=!0);t&&this.persistence&&await this.persistence.setItem(di,this.toBytes());});}get topics(){return [...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return keystore.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}};var As=Es.ec,jr=new As("secp256k1"),ut=k.subtle,xs=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),Bs=Buffer.alloc(32,0);function pe(i,e){if(!i)throw new Error(e||"Assertion failed")}function Ss(i){return Buffer.isBuffer(i)&&i.length===32}function Yr(i){return Ss(i)?i.compare(Bs)>0&&i.compare(xs)<0:!1}function ks(i,e){if(i.length!==e.length)return !1;let t=0;for(let r=0;r<i.length;r++)t|=i[r]^e[r];return t===0}function Qr(i){let e=new Uint8Array(i);return k.getRandomValues(e),Buffer.from(e)}async function ui(i){let e=await ut.digest("SHA-512",i);return Buffer.from(e)}function yi(i){return function(e,t,r){return new Promise(function(s){let o={name:"AES-CBC"};return ut.importKey("raw",t,o,!1,[i]).then(function(c){let p={name:"AES-CBC",iv:e};return ut[i](p,c,r)}).then(function(c){s(Buffer.from(new Uint8Array(c)));})})}}var Ts=yi("encrypt"),Ms=yi("decrypt");async function Br(i,e){let t=await ut.importKey("raw",i,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await ut.sign({name:"HMAC",hash:"SHA-256"},t,e))}async function Ds(i,e,t){let r=await Br(i,e);return ks(r,t)}function Jr(i){return pe(i.length===32,"Bad private key"),pe(Yr(i),"Bad private key"),Buffer.from(jr.keyFromPrivate(i).getPublic("array"))}function li(i,e){return new Promise(function(t){pe(Buffer.isBuffer(i),"Bad private key"),pe(Buffer.isBuffer(e),"Bad public key"),pe(i.length===32,"Bad private key"),pe(Yr(i),"Bad private key"),pe(e.length===65||e.length===33,"Bad public key"),e.length===65&&pe(e[0]===4,"Bad public key"),e.length===33&&pe(e[0]===2||e[0]===3,"Bad public key");let r=jr.keyFromPrivate(i),s=jr.keyFromPublic(e),o=r.derive(s.getPublic());t(Buffer.from(o.toArray()));})}async function mi(i,e,t){t=t||{};let r=t?.iv||Qr(16),s=t?.ephemPrivateKey||Qr(32);for(;!Yr(s);){if(t?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");s=Qr(32);}let o=Jr(s),a=await ui(await li(s,i)),c=a.slice(0,32),p=a.slice(32),y=await Ts(r,c,e),f=Buffer.concat([r,o,y]),K=await Br(p,f);return {iv:r,ephemeralPublicKey:o,ciphertext:y,mac:K}}async function fi(i,e){let t=await li(i,e.ephemeralPublicKey),r=await ui(t),s=r.slice(0,32),o=r.slice(32),a=Buffer.concat([e.iv,e.ephemeralPublicKey,e.ciphertext]);return pe(await Ds(o,a,e.mac),"Bad mac"),Ms(e.iv,s,e.ciphertext)}var{ErrorCode:z}=keystore,Us=new TextEncoder().encode("__XMTP__INVITATION__SALT__XMTP__");async function Is(i,e){let t=await k.subtle.importKey("raw",i,"HKDF",!1,["deriveKey"]);return k.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:Us,info:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}var $=class{v1Keys;v2Keys;inviteStore;authenticator;accountAddress;constructor(e,t){this.v1Keys=e,this.v2Keys=H.fromLegacyBundle(e),this.inviteStore=t,this.authenticator=new Pe(e.identityKey);}static async create(e,t){return new $(e,await le.create(t))}async decryptV1(e){let t=await Ge(e.requests,async r=>{if(!ke(r,["payload","peerKeys"],["headerBytes"]));let{payload:s,peerKeys:o,headerBytes:a,isSender:c}=r;return {decrypted:await ni(this.v1Keys,Wr(o),s,a,c)}},keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);return keystore.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){let t=await Ge(e.requests,async r=>{if(!ke(r,["payload"],["headerBytes"]));let{payload:s,headerBytes:o,contentTopic:a}=r,c=this.inviteStore.lookup(a);if(!c)throw new x(keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return {decrypted:await si(s,Gr(c.invitation),o)}},z.ERROR_CODE_UNSPECIFIED);return keystore.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){let t=await Ge(e.requests,async r=>{if(!ke(r,["payload","recipient"],["headerBytes"]));let{recipient:s,payload:o,headerBytes:a}=r;return {encrypted:await ii(this.v1Keys,Wr(s),o,a)}},z.ERROR_CODE_UNSPECIFIED);return keystore.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?X(e):void 0)}async encryptV2(e){let t=await Ge(e.requests,async r=>{if(!ke(r,["payload"],["headerBytes"]));let{payload:s,headerBytes:o,contentTopic:a}=r,c=this.inviteStore.lookup(a);if(!c)throw new x(z.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return {encrypted:await oi(s,Gr(c.invitation),o)}},z.ERROR_CODE_INVALID_INPUT);return keystore.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){let t=[],r=await Ge(e.requests,async({payload:s,timestampNs:o})=>{let a=ce.fromBytes(s);if(a.v1){if(!a.v1.header.createdNs.equals(o))throw new Error("envelope and header timestamp mismatch");let p=a.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),f={invitation:await a.v1.getInvitation(this.v2Keys),createdNs:a.v1.header.createdNs,peerAddress:p?await a.v1.header.recipient.walletSignatureAddress():await a.v1.header.sender.walletSignatureAddress()};return t.push(f),{conversation:xr(f)}}},z.ERROR_CODE_INVALID_INPUT);return await this.inviteStore.add(t),keystore.SaveInvitesResponse.fromPartial({responses:r})}async createInvite(e){try{if(!ke(e,["recipient"],[]));let t=X(e.createdNs),r=ai(e.recipient),s=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,!1),o=[this.accountAddress,await r.walletSignatureAddress()].sort(),a=(e.context?.conversationId||"")+o.join(),c=new TextEncoder().encode(a),p=F(await Br(Buffer.from(s),Buffer.from(c))),y=["0",...o].join("|"),f=new TextEncoder().encode(y),K=await Is(s,f),me=new Uint8Array(await k.subtle.exportKey("raw",K)),fe=new Ce({topic:et(p),aes256GcmHkdfSha256:{keyMaterial:me},context:e.context}),I=await ce.createV1({sender:this.v2Keys,recipient:r,created:t,invitation:fe}),Oe={invitation:fe,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.inviteStore.add([Oe]),keystore.CreateInviteResponse.fromPartial({conversation:xr(Oe),payload:I.toBytes()})}catch(t){throw Xr(t,z.ERROR_CODE_INVALID_INPUT)}}async signDigest(e){if(!ke(e,["digest"],[]));let{digest:t,identityKey:r,prekeyIndex:s}=e,o;if(r)o=this.v1Keys.identityKey;else if(typeof s<"u"&&Number.isInteger(s)){if(o=this.v1Keys.preKeys[s],!o)throw new x(z.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}else throw new x(z.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");return o.sign(t)}async getV2Conversations(){let e=this.inviteStore.topics.map(t=>xr(t));return e.sort((t,r)=>t.createdNs.div(1e6).sub(r.createdNs.div(1e6)).toNumber()),e}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}lookupTopic(e){return this.inviteStore.lookup(e)}};var Te=class{apiClient;constructor(e){this.apiClient=e;}async getItem(e){for await(let t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:messageApi.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{let r=se(t.message.toString());return Uint8Array.from(r)}catch(r){console.log(r);}return null}async setItem(e,t){let r=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:r}]);}setAuthenticator(e){this.apiClient.setAuthenticator(e);}buildTopic(e){return Dr(e)}};var yt=class{store;constructor(){this.store=new Map;}get length(){return this.store.size}clear(){this.store=new Map;}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(e===void 0)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");let t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e);}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t));}validateString(e){if(typeof e!="string")throw new TypeError("Key must be a string")}};var Me=class{storage;constructor(){this.storage=typeof localStorage<"u"?localStorage:new yt;}async getItem(e){let t=this.storage.getItem(e);return t===null?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"));}};var De=class{prefix;persistence;constructor(e,t){this.prefix=e,this.persistence=t;}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}};var Ue=class{persistence;privateKey;privateKeyBytes;publicKey;constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=Jr(this.privateKeyBytes);}async getItem(e){let t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){let r=await this.encrypt(t);await this.persistence.setItem(e,r);}async encrypt(e){let t=await mi(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){let t=await this.deserializeEcies(e),r=await fi(this.privateKeyBytes,t);return Uint8Array.from(r)}async serializeEcies(e){return (await oe.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){let t=oe.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");let r=t.ciphertext;return {ciphertext:Buffer.from(r.ciphertext),mac:Buffer.from(r.mac),iv:Buffer.from(r.iv),ephemeralPublicKey:Buffer.from(r.ephemeralPublicKey)}}};var Qe=async(i,e)=>{if(!i.persistConversations)return;let t=await e.identityKey.publicKey.walletSignatureAddress(),r=`xmtp/${i.env}/${t}/`;return new De(r,new Ue(new Me,e.identityKey))};var hi="key_bundle",Ie=class{persistence;signer;preEnableIdentityCallback;constructor(e,t,r){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=r;}async getStorageAddress(e){let t=await this.signer.getAddress();return t=utils.getAddress(t),`${t}/${e}`}async loadPrivateKeyBundle(){let e=await this.persistence.getItem(await this.getStorageAddress(hi));if(!e)return null;let[t,r]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return r&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){let t=await this.getStorageAddress(hi),r=await this.toEncryptedBytes(e,this.signer);typeof this.persistence.setAuthenticator=="function"&&this.persistence.setAuthenticator(new Pe(e.identityKey)),await this.persistence.setItem(t,r);}async toEncryptedBytes(e,t){let r=e.encode(),s=k.getRandomValues(new Uint8Array(32)),o=vi(s),a=await t.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();let c=await t.signMessage(o),p=utils.verifyMessage(o,c);if(p!==a&&(c=await t.signMessage(o),console.log("invalid signature, retrying"),p=utils.verifyMessage(o,c),p!==a))throw new Error("invalid signature");let y=L(c),f=await W(r,y);return privateKey.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:s,ciphertext:f}}).finish()}async fromEncryptedBytes(e,t){let[r,s]=Rs(t);if(!r.walletPreKey)throw new Error("missing wallet pre-key");if(!r.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();let o=L(await e.signMessage(vi(r.walletPreKey)));try{let a=new T(r.ciphertext),c=await _(a,o),[p,y]=gi(c);return [p,s||y]}catch{if(o.length!==65)throw new Error("Expected 65 bytes before trying a different recovery byte");let c=o[o.length-1],p=o.slice(0,o.length-1);c<27?p=new Uint8Array([...p,c+27]):p=new Uint8Array([...p,c-27]);let y=new T(r.ciphertext),f=await _(y,p),[K,me]=gi(f);return [K,s||me]}}};function Rs(i){try{let e=privateKey.EncryptedPrivateKeyBundle.decode(i);if(e.v1)return [e.v1,!1]}catch{return [privateKey.EncryptedPrivateKeyBundleV1.decode(i),!0]}throw new Error("unrecognized encrypted private key bundle version")}function gi(i){try{let e=it(i);if(e instanceof H)throw new Error("V2 bundles not supported yet");return [e,!1]}catch{let t=privateKey.PrivateKeyBundleV1.decode(i);return [new Y(t),!0]}}function vi(i){return `XMTP : Enable Identity
${F(i)}

For more info: https://xmtp.org/signatures/`}var Ne=class{async newKeystore(e,t,r){if(!r)throw new re("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();let s=await Y.generate(r);return await new Ie(r,new Te(t),e.preEnableIdentityCallback).storePrivateKeyBundle(s),$.create(s,await Qe(e,s))}};var Re=class{async newKeystore(e,t,r){if(!r)throw new re("No wallet provided");let o=await new Ie(r,new Te(t),e.preEnableIdentityCallback).loadPrivateKeyBundle();if(!o)throw new re("No keys found");return $.create(o,await Qe(e,o))}};var Ve=class{async newKeystore(e){let{privateKeyOverride:t}=e;if(!t)throw new re("No private key override provided");let r=it(t);if(r instanceof H)throw new Error("V2 private key bundle found. Only V1 supported");return $.create(r,await Qe(e,r))}};var {Compression:_s}=content,{b64Decode:Pi}=fetcher,Ki=100*1024*1024;function Fs(i){let e={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new ot],maxContentSize:Ki,persistConversations:!0,skipContactPublishing:!1,keystoreProviders:Hs()};return i?.codecs&&(i.codecs=e.codecs.concat(i.codecs)),{...e,...i}}var Ee=class{address;keystore;apiClient;contacts;publicKeyBundle;knownPublicKeyBundles;_backupClient;_conversations;_codecs;_maxContentSize;constructor(e,t,r,s){this.contacts=new Set,this.knownPublicKeyBundles=new Map,this.keystore=s,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new Se(this),this._codecs=new Map,this._maxContentSize=Ki,this.apiClient=t,this._backupClient=r;}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return P.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){let r=Fs(t),s=Ls(r),o=await qs(r,s,e),a=new b(await o.getPublicKeyBundle()),c=a.walletSignatureAddress();s.setAuthenticator(new ze(o));let p=await Ee.setupBackupClient(c,r.env),y=new Ee(a,s,p,o);return await y.init(r),y}static async getKeys(e,t){let s=await(await Ee.create(e,t)).keystore.getPrivateKeyBundle();return new Y(s).encode()}static async setupBackupClient(e,t){return ri(e,async()=>Promise.resolve({type:t==="local"?1:0}))}async init(e){e.codecs.forEach(t=>{this.registerCodec(t);}),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact);}async close(){}async ensureUserContactPublished(e=!1){let t=await en(this.apiClient,this.address);t&&t instanceof P&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e));}async publishUserContact(e=!1){let t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:tt(this.address),message:Qn(t)}]);}async getUserContact(e){e=utils.getAddress(e);let t=this.knownPublicKeyBundles.get(e);if(t)return t;let r=await en(this.apiClient,e);return r&&this.knownPublicKeyBundles.set(e,r),r}async getUserContacts(e){let t=e.map(a=>utils.getAddress(a)),r=new Map,s=[];for(let a of t){let c=this.knownPublicKeyBundles.get(a);c?r.set(a,c):(r.set(a,void 0),s.push(a));}let o=await wi(this.apiClient,s);for(let a=0;a<o.length;a++){let c=s[a],p=o[a];r.set(c,p),p&&this.knownPublicKeyBundles.set(c,p);}return t.map(a=>r.get(a))}forgetContact(e){e=utils.getAddress(e),this.knownPublicKeyBundles.delete(e);}async canMessage(e){try{return Array.isArray(e)?(await this.getUserContacts(e)).map(s=>!!s):await this.getUserContact(e)!==void 0}catch{return !1}}static async canMessage(e,t){let r=t?.apiUrl||pt[t?.env||"dev"];if(Array.isArray(e)){let a=e.map(p=>utils.getAddress(p));return (await wi(new Be(r,{appVersion:t?.appVersion}),a)).map(p=>!!p)}try{e=utils.getAddress(e);}catch{return !1}return await en(new Be(r,{appVersion:t?.appVersion}),e)!==void 0}validateEnvelope(e){let t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(let t of e)this.validateEnvelope(t);await this.apiClient.publish(e);}registerCodec(e){let t=e.contentType,r=`${t.authorityId}/${t.typeId}`;this._codecs.set(r,e);}codecFor(e){let t=`${e.authorityId}/${e.typeId}`,r=this._codecs.get(t);if(r&&!(e.versionMajor>r.contentType.versionMajor))return r}async encodeContent(e,t){let r=t?.contentType||we,s=this.codecFor(r);if(!s)throw new Error("unknown content type "+r);let o=s.encode(e,this);return t?.contentFallback&&(o.fallback=t.contentFallback),typeof t?.compression=="number"&&(o.compression=t.compression),await On(o),content.EncodedContent.encode(o).finish()}listInvitations(e){return this.listEnvelopes(ge(this.address),async t=>t,e)}async listEnvelopes(e,t,r){r||(r={});let{startTime:s,endTime:o,limit:a}=r,c=await this.apiClient.query({contentTopic:e,startTime:s,endTime:o},{direction:r.direction||messageApi.SortDirection.SORT_DIRECTION_ASCENDING,limit:a}),p=[];for(let y of c)if(y.message)try{let f=await t(y);p.push(f);}catch(f){console.warn("Error in listEnvelopes mapper",f);}return p}listEnvelopesPaginated(e,t,r){return Ur(this.apiClient.queryIteratePages({contentTopic:e,startTime:r?.startTime,endTime:r?.endTime},{direction:r?.direction,pageSize:r?.pageSize||100}),t)}};function Ls(i){let e=i.apiUrl||pt[i.env];return new Be(e,{appVersion:i.appVersion})}async function en(i,e){let t=i.queryIterator({contentTopic:tt(e)},{pageSize:5,direction:ye.SORT_DIRECTION_DESCENDING});for await(let r of t){if(!r.message)continue;let s=Er(Pi(r.message.toString())),o;try{o=await s?.walletSignatureAddress();}catch{o=void 0;}if(o===e)return s}}async function wi(i,e){let t=e.map(tt),r=await i.batchQuery(t.map(s=>({contentTopic:s,pageSize:5,direction:ye.SORT_DIRECTION_DESCENDING})));return Promise.all(e.map(async(s,o)=>{let a=r[o];if(a){for(let c of a)if(c.message)try{let p=Er(Pi(c.message.toString())),y=await p?.walletSignatureAddress();if(s===y)return p;console.info("Received contact bundle with incorrect address");}catch(p){console.info("Invalid contact bundle",p);}}}))}function Hs(){return [new Ve,new Re,new Ne]}async function qs(i,e,t){for(let r of i.keystoreProviders)try{return await r.newKeystore(i,e,t??void 0)}catch(s){if(s instanceof re)continue;throw s}throw new Error("No keystore providers available")}var tn=new q({authorityId:"xmtp.com",typeId:"typingNotification",versionMajor:1,versionMinor:0}),rn=class{get contentType(){return tn}encode(e){return {type:tn,parameters:{timestamp:e.timestamp.toISOString(),typerAddress:e.typerAddress,isFinished:e.isFinished?"true":"false"},content:new Uint8Array}}decode(e){let t=new Date(e.parameters.timestamp),r=e.parameters.senderAddress,s=e.parameters.isFinished==="true";return {timestamp:t,typerAddress:r,isFinished:s}}};var nn=new q({authorityId:"xmtp.org",typeId:"composite",versionMajor:1,versionMinor:0}),sn=class{get contentType(){return nn}encode(e,t){let r=this.toProto(e,t),s;r.composite?s=r.composite:s={parts:[r]};let o=composite.Composite.encode(s).finish();return {type:nn,parameters:{},content:o}}decode(e,t){return this.fromProto({composite:composite.Composite.decode(e.content),part:void 0},t)}toProto(e,t){if("type"in e){let s=t.codecFor(e.type);if(!s)throw new Error(`missing codec for part type ${e.type}`);return {part:s.encode(e.content,t),composite:void 0}}let r=new Array;for(let s of e.parts)r.push(this.toProto(s,t));return {composite:{parts:r},part:void 0}}fromProto(e,t){if(e.part){if(!e.part.type)throw new Error("missing part content type");let s=new q(e.part.type),o=t.codecFor(s);if(!o)throw new Error(`missing codec for part type ${s}`);return {type:s,content:o.decode(e.part,t)}}if(!e.composite)throw new Error("invalid composite");let r=new Array;for(let s of e.composite.parts)r.push(this.fromProto(s,t));return {parts:r}}};/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/

export { pt as ApiUrls, T as Ciphertext, Ee as Client, sn as CompositeCodec, _s as Compression, nn as ContentTypeComposite, Fr as ContentTypeFallback, q as ContentTypeId, we as ContentTypeText, tn as ContentTypeTypingNotification, Se as Conversations, R as DecodedMessage, Ue as EncryptedPersistence, $ as InMemoryKeystore, Ne as KeyGeneratorKeystoreProvider, Me as LocalStoragePersistence, O as MessageV1, be as MessageV2, Re as NetworkKeystoreProvider, De as PrefixedPersistence, G as PrivateKey, D as PublicKey, b as PublicKeyBundle, ce as SealedInvitation, A as Signature, E as SignedPublicKey, P as SignedPublicKeyBundle, ye as SortDirection, Ve as StaticKeystoreProvider, V as Stream, ot as TextCodec, rn as TypingNotificationCodec, Ae as buildContentTopic, Fe as buildDirectMessageTopic, et as buildDirectMessageTopicV2, tt as buildUserContactTopic, ne as buildUserIntroTopic, ge as buildUserInviteTopic, Dr as buildUserPrivateStoreTopic, N as dateToNs, Er as decodeContactBundle, at as decodeContent, _ as decrypt, W as encrypt, Ii as fromNanoString, Ur as mapPaginatedStream, X as nsToDate, ie as toNanoString };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map