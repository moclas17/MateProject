import { utils } from 'ethers';
import Long from 'long';
import { ciphertext, privateKey, signature, publicKey, message, content, messageApi, contact, invitation, keystore, composite, fetcher, authn } from '@xmtp/proto';
import * as secp2 from '@noble/secp256k1';
import { webcrypto as webcrypto$1 } from 'crypto';
import { Mutex } from 'async-mutex';
import elliptic from 'elliptic';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message2) {
          return new Keccak(bits2, padding, bits2).update(message2)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message2, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message2)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message2, outputBits, n, s) {
          return methods["cshake" + bits2].update(message2, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message2, outputBits, s) {
          return methods["kmac" + bits2].update(key, message2, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message2) {
          return method.create().update(message2);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message2, outputBits) {
          return method.create(outputBits).update(message2);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message2, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message2);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message2, outputBits, s) {
          return method.create(key, outputBits, s).update(message2);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message2) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message2;
        if (type !== "string") {
          if (type === "object") {
            if (message2 === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
              message2 = new Uint8Array(message2);
            } else if (!Array.isArray(message2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message2)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message2.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message2[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message2.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message2.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});
var buildContentTopic = (name) => `/xmtp/0/${name}/proto`;
var buildDirectMessageTopic = (sender, recipient) => {
  const members = [utils.getAddress(sender), utils.getAddress(recipient)];
  members.sort();
  return buildContentTopic(`dm-${members.join("-")}`);
};
var buildDirectMessageTopicV2 = (randomString) => {
  return buildContentTopic(`m-${randomString}`);
};
var buildUserContactTopic = (walletAddr) => {
  return buildContentTopic(`contact-${utils.getAddress(walletAddr)}`);
};
var buildUserIntroTopic = (walletAddr) => {
  return buildContentTopic(`intro-${utils.getAddress(walletAddr)}`);
};
var buildUserInviteTopic = (walletAddr) => {
  return buildContentTopic(`invite-${utils.getAddress(walletAddr)}`);
};
var buildUserPrivateStoreTopic = (addrPrefixedKey) => {
  return buildContentTopic(`privatestore-${addrPrefixedKey}`);
};

// src/utils/async.ts
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var defaultIsRetryableFn = (err) => !!err;
async function retry(fn, args, maxRetries, sleepTime, isRetryableFn = defaultIsRetryableFn, retryCount = 1) {
  const currRetry = typeof retryCount === "number" ? retryCount : 1;
  try {
    const result = await fn(...args);
    return result;
  } catch (e) {
    if (!isRetryableFn(e) || currRetry > maxRetries) {
      throw e;
    }
    await sleep(sleepTime);
    return retry(fn, args, maxRetries, sleepTime, isRetryableFn, currRetry + 1);
  }
}
async function* mapPaginatedStream(gen, mapper) {
  for await (const page of gen) {
    const results = await Promise.allSettled(page.map(mapper));
    const out = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        out.push(result.value);
      } else {
        console.warn(
          "Failed to process envelope due to reason: ",
          result.reason
        );
      }
    }
    yield out;
  }
}
function dateToNs(date) {
  return Long.fromNumber(date.valueOf()).multiply(1e6);
}
function nsToDate(ns) {
  return new Date(ns.divide(1e6).toNumber());
}
var toNanoString = (d) => {
  return d && dateToNs(d).toString();
};
var fromNanoString = (s) => {
  if (!s) {
    return void 0;
  }
  return nsToDate(Long.fromString(s));
};
var { b64Decode, b64Encode } = fetcher;
function concat(a, b) {
  const ab = new Uint8Array(a.length + b.length);
  ab.set(a);
  ab.set(b, a.length);
  return ab;
}

// src/Stream.ts
var Stream = class {
  constructor(client, topics, decoder, contentTopicUpdater) {
    this.messages = [];
    this.resolvers = [];
    this.topics = topics;
    this.client = client;
    this.callback = this.newMessageCallback(decoder, contentTopicUpdater);
  }
  // returns new closure to handle incoming messages
  newMessageCallback(decoder, contentTopicUpdater) {
    return async (env) => {
      if (!env.message) {
        return;
      }
      try {
        const msg = await decoder(env);
        if (!msg) {
          return;
        }
        if (contentTopicUpdater) {
          const topics = contentTopicUpdater(msg);
          if (topics) {
            this.resubscribeToTopics(topics);
          }
        }
        const resolver = this.resolvers.pop();
        if (resolver) {
          resolver({ value: msg });
        } else {
          this.messages.unshift(msg);
        }
      } catch (e) {
        console.warn(e);
      }
    };
  }
  async start() {
    if (!this.callback) {
      throw new Error("Missing callback for stream");
    }
    this.unsubscribeFn = this.client.apiClient.subscribe(
      {
        contentTopics: this.topics
      },
      async (env) => {
        if (!this.callback)
          return;
        await this?.callback(env);
      }
    );
  }
  static async create(client, topics, decoder, contentTopicUpdater) {
    const stream = new Stream(client, topics, decoder, contentTopicUpdater);
    await stream.start();
    return stream;
  }
  // To make Stream proper Async Iterable
  [Symbol.asyncIterator]() {
    return this;
  }
  // return should be called if the interpreter detects that the stream won't be used anymore,
  // e.g. a for/of loop was exited via a break. It can also be called explicitly.
  // https://tc39.es/ecma262/#table-iterator-interface-optional-properties
  // Note that this means the Stream will be closed after it was used in a for-await-of or yield* or similar.
  async return() {
    if (this.unsubscribeFn) {
      await this.unsubscribeFn();
    }
    if (!this.callback) {
      return { value: void 0, done: true };
    }
    this.callback = void 0;
    this.resolvers.forEach(
      (resolve) => resolve({ value: void 0, done: true })
    );
    return { value: void 0, done: true };
  }
  // To make Stream proper Async Iterator
  // Note that next() will still provide whatever messages were already pending
  // even after the stream was closed via return().
  next() {
    const msg = this.messages.pop();
    if (msg) {
      return Promise.resolve({ value: msg });
    }
    if (!this.callback) {
      return Promise.resolve({ value: void 0, done: true });
    }
    return new Promise((resolve) => this.resolvers.unshift(resolve));
  }
  // Unsubscribe from the existing content topics and resubscribe to the given topics.
  async resubscribeToTopics(topics) {
    if (!this.callback || !this.unsubscribeFn) {
      throw new Error("Missing callback for stream");
    }
    await this.unsubscribeFn();
    this.topics = topics;
    this.unsubscribeFn = this.client.apiClient.subscribe(
      {
        contentTopics: this.topics
      },
      async (env) => {
        if (!this.callback)
          return;
        await this?.callback(env);
      }
    );
  }
};
var KDFSaltSize = 32;
var AESGCMNonceSize = 12;
var AESGCMTagLength = 16;
var Ciphertext = class {
  // eslint-disable-line camelcase
  constructor(obj) {
    if (!obj.aes256GcmHkdfSha256) {
      throw new Error("invalid ciphertext");
    }
    if (obj.aes256GcmHkdfSha256.payload.length < AESGCMTagLength) {
      throw new Error(
        `invalid ciphertext ciphertext length: ${obj.aes256GcmHkdfSha256.payload.length}`
      );
    }
    if (obj.aes256GcmHkdfSha256.hkdfSalt.length !== KDFSaltSize) {
      throw new Error(
        `invalid ciphertext salt length: ${obj.aes256GcmHkdfSha256.hkdfSalt.length}`
      );
    }
    if (obj.aes256GcmHkdfSha256.gcmNonce.length !== AESGCMNonceSize) {
      throw new Error(
        `invalid ciphertext nonce length: ${obj.aes256GcmHkdfSha256.gcmNonce.length}`
      );
    }
    this.aes256GcmHkdfSha256 = obj.aes256GcmHkdfSha256;
  }
  toBytes() {
    return ciphertext.Ciphertext.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new Ciphertext(ciphertext.Ciphertext.decode(bytes));
  }
};
var webcrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var crypto = webcrypto ?? webcrypto$1;
var crypto_default = crypto;

// src/crypto/encryption.ts
var hkdfNoInfo = new ArrayBuffer(0);
async function sha256(bytes) {
  return new Uint8Array(await crypto_default.subtle.digest("SHA-256", bytes));
}
async function encrypt(plain, secret, additionalData) {
  const salt = crypto_default.getRandomValues(new Uint8Array(KDFSaltSize));
  const nonce = crypto_default.getRandomValues(new Uint8Array(AESGCMNonceSize));
  const key = await hkdf(secret, salt);
  const encrypted = await crypto_default.subtle.encrypt(
    aesGcmParams(nonce, additionalData),
    key,
    plain
  );
  return new Ciphertext({
    aes256GcmHkdfSha256: {
      payload: new Uint8Array(encrypted),
      hkdfSalt: salt,
      gcmNonce: nonce
    }
  });
}
async function decrypt(encrypted, secret, additionalData) {
  if (!encrypted.aes256GcmHkdfSha256) {
    throw new Error("invalid payload ciphertext");
  }
  const key = await hkdf(secret, encrypted.aes256GcmHkdfSha256.hkdfSalt);
  const decrypted = await crypto_default.subtle.decrypt(
    aesGcmParams(encrypted.aes256GcmHkdfSha256.gcmNonce, additionalData),
    key,
    encrypted.aes256GcmHkdfSha256.payload
  );
  return new Uint8Array(decrypted);
}
function aesGcmParams(nonce, additionalData) {
  const spec = {
    name: "AES-GCM",
    iv: nonce
  };
  if (additionalData) {
    spec.additionalData = additionalData;
  }
  return spec;
}
async function hkdf(secret, salt) {
  const key = await crypto_default.subtle.importKey("raw", secret, "HKDF", false, [
    "deriveKey"
  ]);
  return crypto_default.subtle.deriveKey(
    { name: "HKDF", hash: "SHA-256", salt, info: hkdfNoInfo },
    key,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
var bytesToHex = secp2.utils.bytesToHex;
function hexToBytes(s) {
  if (s.startsWith("0x")) {
    s = s.slice(2);
  }
  const bytes = new Uint8Array(s.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const j = i * 2;
    bytes[i] = Number.parseInt(s.slice(j, j + 2), 16);
  }
  return bytes;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// src/crypto/PrivateKey.ts
function secp256k1Check(key) {
  if (key.bytes.length !== 32) {
    throw new Error(`invalid private key length: ${key.bytes.length}`);
  }
}
var SignedPrivateKey = class {
  // caches corresponding PublicKey
  constructor(obj) {
    if (!obj.secp256k1) {
      throw new Error("invalid private key");
    }
    secp256k1Check(obj.secp256k1);
    this.secp256k1 = obj.secp256k1;
    this.createdNs = obj.createdNs;
    if (!obj.publicKey) {
      throw new Error("missing public key");
    }
    this.publicKey = new SignedPublicKey(obj.publicKey);
  }
  // Create a random key pair signed by the signer.
  static async generate(signer) {
    const secp256k1 = {
      bytes: secp2.utils.randomPrivateKey()
    };
    const createdNs = Long.fromNumber((/* @__PURE__ */ new Date()).getTime()).mul(1e6);
    const unsigned = new UnsignedPublicKey({
      secp256k1Uncompressed: {
        bytes: secp2.getPublicKey(secp256k1.bytes)
      },
      createdNs
    });
    const signed = await signer.signKey(unsigned);
    return new SignedPrivateKey({
      secp256k1,
      createdNs,
      publicKey: signed
    });
  }
  // Time the key was generated.
  generated() {
    return new Date(this.createdNs.div(1e6).toNumber());
  }
  // Sign provided digest.
  async sign(digest) {
    const [signature5, recovery] = await secp2.sign(
      digest,
      this.secp256k1.bytes,
      {
        recovered: true,
        der: false
      }
    );
    return new Signature({
      ecdsaCompact: { bytes: signature5, recovery }
    });
  }
  // Sign provided public key.
  async signKey(pub) {
    const keyBytes = pub.toBytes();
    const digest = await sha256(keyBytes);
    const signature5 = await this.sign(digest);
    return new SignedPublicKey({
      keyBytes,
      signature: signature5
    });
  }
  // Return public key of the signer of the provided signed key.
  static async signerKey(key, signature5) {
    const digest = await sha256(key.bytesToSign());
    return ecdsaSignerKey(digest, signature5);
  }
  // Derive shared secret from peer's PublicKey;
  // the peer can derive the same secret using their private key and our public key.
  sharedSecret(peer) {
    return secp2.getSharedSecret(
      this.secp256k1.bytes,
      peer.secp256k1Uncompressed.bytes,
      false
    );
  }
  // encrypt plain bytes using a shared secret derived from peer's PublicKey;
  // additionalData allows including unencrypted parts of a Message in the authentication
  // protection provided by the encrypted part (to make the whole Message tamper evident)
  encrypt(plain, peer, additionalData) {
    const secret = this.sharedSecret(peer);
    return encrypt(plain, secret, additionalData);
  }
  // decrypt Ciphertext using a shared secret derived from peer's PublicKey;
  // throws if any part of Ciphertext or additionalData was tampered with
  decrypt(encrypted, peer, additionalData) {
    const secret = this.sharedSecret(peer);
    return decrypt(encrypted, secret, additionalData);
  }
  // Does the provided PublicKey correspond to this PrivateKey?
  matches(key) {
    return this.publicKey.equals(key);
  }
  // Is other the same/equivalent key?
  equals(other) {
    return equalBytes(this.secp256k1.bytes, other.secp256k1.bytes) && this.publicKey.equals(other.publicKey);
  }
  // Encode this key into bytes.
  toBytes() {
    return privateKey.SignedPrivateKey.encode(this).finish();
  }
  // Decode key from bytes.
  static fromBytes(bytes) {
    return new SignedPrivateKey(privateKey.SignedPrivateKey.decode(bytes));
  }
  static fromLegacyKey(key, signedByWallet) {
    return new SignedPrivateKey({
      createdNs: key.timestamp.mul(1e6),
      secp256k1: key.secp256k1,
      publicKey: SignedPublicKey.fromLegacyKey(key.publicKey, signedByWallet)
    });
  }
};
var PrivateKey = class {
  // caches corresponding PublicKey
  constructor(obj) {
    if (!obj.secp256k1) {
      throw new Error("invalid private key");
    }
    secp256k1Check(obj.secp256k1);
    this.timestamp = obj.timestamp;
    this.secp256k1 = obj.secp256k1;
    if (!obj.publicKey) {
      throw new Error("missing public key");
    }
    this.publicKey = new PublicKey(obj.publicKey);
  }
  // create a random PrivateKey/PublicKey pair.
  static generate() {
    const secp256k1 = {
      bytes: secp2.utils.randomPrivateKey()
    };
    const timestamp = Long.fromNumber((/* @__PURE__ */ new Date()).getTime());
    return new PrivateKey({
      secp256k1,
      timestamp,
      publicKey: new PublicKey({
        secp256k1Uncompressed: {
          bytes: secp2.getPublicKey(secp256k1.bytes)
        },
        timestamp
      })
    });
  }
  generated() {
    return new Date(this.timestamp.toNumber());
  }
  // sign provided digest
  async sign(digest) {
    const [signature5, recovery] = await secp2.sign(
      digest,
      this.secp256k1.bytes,
      {
        recovered: true,
        der: false
      }
    );
    return new Signature({
      ecdsaCompact: { bytes: signature5, recovery }
    });
  }
  // sign provided public key
  async signKey(pub) {
    const digest = await sha256(pub.bytesToSign());
    pub.signature = await this.sign(digest);
    return pub;
  }
  // derive shared secret from peer's PublicKey;
  // the peer can derive the same secret using their PrivateKey and our PublicKey
  sharedSecret(peer) {
    return secp2.getSharedSecret(
      this.secp256k1.bytes,
      peer.secp256k1Uncompressed.bytes,
      false
    );
  }
  // encrypt plain bytes using a shared secret derived from peer's PublicKey;
  // additionalData allows including unencrypted parts of a Message in the authentication
  // protection provided by the encrypted part (to make the whole Message tamper evident)
  encrypt(plain, peer, additionalData) {
    const secret = this.sharedSecret(peer);
    return encrypt(plain, secret, additionalData);
  }
  // decrypt Ciphertext using a shared secret derived from peer's PublicKey;
  // throws if any part of Ciphertext or additionalData was tampered with
  decrypt(encrypted, peer, additionalData) {
    const secret = this.sharedSecret(peer);
    return decrypt(encrypted, secret, additionalData);
  }
  // Does the provided PublicKey correspond to this PrivateKey?
  matches(key) {
    return this.publicKey.equals(key);
  }
  // Encode this key into bytes.
  toBytes() {
    return privateKey.PrivateKey.encode(this).finish();
  }
  // Decode key from bytes.
  static fromBytes(bytes) {
    return new PrivateKey(privateKey.PrivateKey.decode(bytes));
  }
};
function ecdsaCheck(sig) {
  if (sig.bytes.length !== 64) {
    throw new Error(`invalid signature length: ${sig.bytes.length}`);
  }
  if (sig.recovery !== 0 && sig.recovery !== 1) {
    throw new Error(`invalid recovery bit: ${sig.recovery}`);
  }
}
function ecdsaEqual(a, b) {
  return a.recovery === b.recovery && equalBytes(a.bytes, b.bytes);
}
function ecdsaSignerKey(digest, signature5) {
  const bytes = secp2.recoverPublicKey(
    digest,
    signature5.bytes,
    signature5.recovery
  );
  return bytes ? new UnsignedPublicKey({
    secp256k1Uncompressed: { bytes },
    createdNs: Long.fromNumber(0)
  }) : void 0;
}
var Signature = class {
  // eslint-disable-line camelcase
  constructor(obj) {
    if (obj.ecdsaCompact) {
      ecdsaCheck(obj.ecdsaCompact);
      this.ecdsaCompact = obj.ecdsaCompact;
    } else if (obj.walletEcdsaCompact) {
      ecdsaCheck(obj.walletEcdsaCompact);
      this.walletEcdsaCompact = obj.walletEcdsaCompact;
    } else {
      throw new Error("invalid signature");
    }
  }
  // Return the public key that validates provided key's signature.
  async signerKey(key) {
    if (this.ecdsaCompact) {
      return SignedPrivateKey.signerKey(key, this.ecdsaCompact);
    } else if (this.walletEcdsaCompact) {
      return WalletSigner.signerKey(key, this.walletEcdsaCompact);
    } else {
      return void 0;
    }
  }
  // LEGACY: Return the public key that validates this signature given the provided digest.
  // Return undefined if the signature is malformed.
  getPublicKey(digest) {
    let bytes;
    if (this.ecdsaCompact) {
      bytes = secp2.recoverPublicKey(
        digest,
        this.ecdsaCompact.bytes,
        this.ecdsaCompact.recovery
      );
    } else if (this.walletEcdsaCompact) {
      bytes = secp2.recoverPublicKey(
        digest,
        this.walletEcdsaCompact.bytes,
        this.walletEcdsaCompact.recovery
      );
    } else {
      throw new Error("invalid v1 signature");
    }
    return bytes ? new PublicKey({
      secp256k1Uncompressed: { bytes },
      timestamp: Long.fromNumber(0)
    }) : void 0;
  }
  // Is this the same/equivalent signature as other?
  equals(other) {
    if (this.ecdsaCompact && other.ecdsaCompact) {
      return ecdsaEqual(this.ecdsaCompact, other.ecdsaCompact);
    }
    if (this.walletEcdsaCompact && other.walletEcdsaCompact) {
      return ecdsaEqual(this.walletEcdsaCompact, other.walletEcdsaCompact);
    }
    return false;
  }
  toBytes() {
    return signature.Signature.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new Signature(signature.Signature.decode(bytes));
  }
};
var WalletSigner = class {
  constructor(wallet) {
    this.wallet = wallet;
  }
  static identitySigRequestText(keyBytes) {
    return `XMTP : Create Identity
${bytesToHex(keyBytes)}

For more info: https://xmtp.org/signatures/`;
  }
  static signerKey(key, signature5) {
    const digest = hexToBytes(
      utils.hashMessage(this.identitySigRequestText(key.bytesToSign()))
    );
    return ecdsaSignerKey(digest, signature5);
  }
  async signKey(key) {
    const keyBytes = key.toBytes();
    const sigString = await this.wallet.signMessage(
      WalletSigner.identitySigRequestText(keyBytes)
    );
    const eSig = utils.splitSignature(sigString);
    const r = hexToBytes(eSig.r);
    const s = hexToBytes(eSig.s);
    const sigBytes = new Uint8Array(64);
    sigBytes.set(r);
    sigBytes.set(s, r.length);
    const signature5 = new Signature({
      walletEcdsaCompact: {
        bytes: sigBytes,
        recovery: eSig.recoveryParam
      }
    });
    return new SignedPublicKey({ keyBytes, signature: signature5 });
  }
};
function secp256k1UncompressedCheck(key) {
  if (key.bytes.length !== 65) {
    throw new Error(`invalid public key length: ${key.bytes.length}`);
  }
  if (key.bytes[0] !== 4) {
    throw new Error(`unrecognized public key prefix: ${key.bytes[0]}`);
  }
}
var MS_NS_TIMESTAMP_THRESHOLD = new Long(10 ** 9).mul(10 ** 9);
var UnsignedPublicKey = class {
  // eslint-disable-line camelcase
  constructor(obj) {
    if (!obj?.secp256k1Uncompressed) {
      throw new Error("invalid public key");
    }
    secp256k1UncompressedCheck(obj.secp256k1Uncompressed);
    this.secp256k1Uncompressed = obj.secp256k1Uncompressed;
    this.createdNs = obj.createdNs.toUnsigned();
  }
  // The time the key was generated.
  generated() {
    return new Date(this.timestamp.toNumber());
  }
  isFromLegacyKey() {
    return this.createdNs.lessThan(MS_NS_TIMESTAMP_THRESHOLD);
  }
  // creation time in milliseconds
  get timestamp() {
    return (this.isFromLegacyKey() ? this.createdNs : this.createdNs.div(1e6)).toUnsigned();
  }
  // Verify that signature was created from the digest using matching private key.
  verify(signature5, digest) {
    if (!signature5.ecdsaCompact) {
      return false;
    }
    return secp2.verify(
      signature5.ecdsaCompact.bytes,
      digest,
      this.secp256k1Uncompressed.bytes
    );
  }
  // Verify that the provided public key was signed by matching private key.
  async verifyKey(pub) {
    if (!pub.signature) {
      return false;
    }
    const digest = await sha256(pub.bytesToSign());
    return this.verify(pub.signature, digest);
  }
  // Is other the same/equivalent public key?
  equals(other) {
    return equalBytes(
      this.secp256k1Uncompressed.bytes,
      other.secp256k1Uncompressed.bytes
    );
  }
  // Derive Ethereum address from this public key.
  getEthereumAddress() {
    return utils.computeAddress(this.secp256k1Uncompressed.bytes);
  }
  // Encode public key into bytes.
  toBytes() {
    return publicKey.UnsignedPublicKey.encode(this).finish();
  }
  // Decode public key from bytes.
  static fromBytes(bytes) {
    return new UnsignedPublicKey(publicKey.UnsignedPublicKey.decode(bytes));
  }
};
var SignedPublicKey = class extends UnsignedPublicKey {
  constructor(obj) {
    if (!obj.keyBytes) {
      throw new Error("missing key bytes");
    }
    super(publicKey.UnsignedPublicKey.decode(obj.keyBytes));
    this.keyBytes = obj.keyBytes;
    if (!obj.signature) {
      throw new Error("missing key signature");
    }
    this.signature = new Signature(obj.signature);
  }
  // Return the key without the signature.
  get unsignedKey() {
    return new UnsignedPublicKey({
      createdNs: this.createdNs,
      secp256k1Uncompressed: this.secp256k1Uncompressed
    });
  }
  // Return public key of the signer of this key.
  signerKey() {
    return this.signature.signerKey(this);
  }
  // Assume the key was signed by a wallet and
  // return the wallet address that validates
  // the signature of this key.
  async walletSignatureAddress() {
    if (!this.signature.walletEcdsaCompact) {
      throw new Error("key was not signed by a wallet");
    }
    const pk = await this.signerKey();
    if (!pk) {
      throw new Error("key signature not valid");
    }
    return pk.getEthereumAddress();
  }
  // Is other the same/equivalent public key?
  equals(other) {
    return this.unsignedKey.equals(other.unsignedKey) && this.signature.equals(other.signature);
  }
  // Return bytes of the encoded unsigned key.
  bytesToSign() {
    return this.keyBytes;
  }
  // Encode signed key into bytes.
  toBytes() {
    return publicKey.SignedPublicKey.encode(this).finish();
  }
  // Decode signed key from bytes.
  static fromBytes(bytes) {
    return new SignedPublicKey(publicKey.SignedPublicKey.decode(bytes));
  }
  toLegacyKey() {
    if (!this.isFromLegacyKey()) {
      throw new Error("cannot be converted to legacy key");
    }
    let signature5 = this.signature;
    if (signature5.walletEcdsaCompact) {
      signature5 = new Signature({
        ecdsaCompact: signature5.walletEcdsaCompact
      });
    }
    return new PublicKey({
      timestamp: this.timestamp,
      secp256k1Uncompressed: this.secp256k1Uncompressed,
      signature: signature5
    });
  }
  static fromLegacyKey(legacyKey, signedByWallet) {
    if (!legacyKey.signature) {
      throw new Error("key is not signed");
    }
    let signature5 = legacyKey.signature;
    if (signedByWallet) {
      signature5 = new Signature({
        walletEcdsaCompact: signature5.ecdsaCompact
      });
    }
    return new SignedPublicKey({
      keyBytes: legacyKey.bytesToSign(),
      signature: signature5
    });
  }
};
var PublicKey = class extends UnsignedPublicKey {
  constructor(obj) {
    super({
      createdNs: obj.timestamp.mul(1e6),
      secp256k1Uncompressed: obj.secp256k1Uncompressed
    });
    if (obj.signature) {
      if (!obj.signature.ecdsaCompact && obj.signature.walletEcdsaCompact) {
        this.signature = new Signature({
          ecdsaCompact: {
            bytes: obj.signature.walletEcdsaCompact.bytes,
            recovery: obj.signature.walletEcdsaCompact.recovery
          }
        });
      } else {
        this.signature = new Signature(obj.signature);
      }
    }
  }
  get timestamp() {
    return this.createdNs.div(1e6);
  }
  bytesToSign() {
    return publicKey.PublicKey.encode({
      timestamp: this.timestamp,
      secp256k1Uncompressed: this.secp256k1Uncompressed
    }).finish();
  }
  // sign the key using a wallet
  async signWithWallet(wallet) {
    const sigString = await wallet.signMessage(
      WalletSigner.identitySigRequestText(this.bytesToSign())
    );
    const eSig = utils.splitSignature(sigString);
    const r = hexToBytes(eSig.r);
    const s = hexToBytes(eSig.s);
    const sigBytes = new Uint8Array(64);
    sigBytes.set(r);
    sigBytes.set(s, r.length);
    this.signature = new Signature({
      ecdsaCompact: {
        bytes: sigBytes,
        recovery: eSig.recoveryParam
      }
    });
  }
  // Assume the key was signed by a wallet and
  // return the wallet address that validates
  // the signature for this key.
  walletSignatureAddress() {
    if (!this.signature) {
      throw new Error("key is not signed");
    }
    const digest = hexToBytes(
      utils.hashMessage(WalletSigner.identitySigRequestText(this.bytesToSign()))
    );
    const pk = this.signature.getPublicKey(digest);
    if (!pk) {
      throw new Error("key signature is malformed");
    }
    return pk.getEthereumAddress();
  }
  toBytes() {
    return publicKey.PublicKey.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new PublicKey(publicKey.PublicKey.decode(bytes));
  }
};

// src/crypto/PublicKeyBundle.ts
var SignedPublicKeyBundle = class {
  constructor(bundle) {
    if (!bundle.identityKey) {
      throw new Error("missing identity key");
    }
    if (!bundle.preKey) {
      throw new Error("missing pre-key");
    }
    this.identityKey = new SignedPublicKey(bundle.identityKey);
    this.preKey = new SignedPublicKey(bundle.preKey);
  }
  walletSignatureAddress() {
    return this.identityKey.walletSignatureAddress();
  }
  equals(other) {
    return this.identityKey.equals(other.identityKey) && this.preKey.equals(other.preKey);
  }
  toBytes() {
    return publicKey.SignedPublicKeyBundle.encode(this).finish();
  }
  isFromLegacyBundle() {
    return this.identityKey.isFromLegacyKey() && this.preKey.isFromLegacyKey();
  }
  toLegacyBundle() {
    return new PublicKeyBundle({
      identityKey: this.identityKey.toLegacyKey(),
      preKey: this.preKey.toLegacyKey()
    });
  }
  static fromBytes(bytes) {
    const decoded = publicKey.SignedPublicKeyBundle.decode(bytes);
    return new SignedPublicKeyBundle(decoded);
  }
  static fromLegacyBundle(bundle) {
    return new SignedPublicKeyBundle({
      // Note: I am assuming all PublicKeyBundles passed into this have had their identity keys signed by a wallet
      // Maybe that is not universally true in the future
      identityKey: SignedPublicKey.fromLegacyKey(bundle.identityKey, true),
      preKey: SignedPublicKey.fromLegacyKey(bundle.preKey)
    });
  }
};
var PublicKeyBundle = class {
  constructor(bundle) {
    if (!bundle.identityKey) {
      throw new Error("missing identity key");
    }
    if (!bundle.preKey) {
      throw new Error("missing pre-key");
    }
    this.identityKey = new PublicKey(bundle.identityKey);
    this.preKey = new PublicKey(bundle.preKey);
  }
  equals(other) {
    return this.identityKey.equals(other.identityKey) && this.preKey.equals(other.preKey);
  }
  walletSignatureAddress() {
    return this.identityKey.walletSignatureAddress();
  }
  toBytes() {
    return publicKey.PublicKeyBundle.encode(this).finish();
  }
  static fromBytes(bytes) {
    const decoded = publicKey.PublicKeyBundle.decode(bytes);
    return new PublicKeyBundle(decoded);
  }
};

// src/crypto/errors.ts
var NoMatchingPreKeyError = class extends Error {
  constructor(preKey) {
    super(
      `no pre-key matches: ${bytesToHex(preKey.secp256k1Uncompressed.bytes)}`
    );
  }
};

// src/crypto/PrivateKeyBundle.ts
var PrivateKeyBundleV2 = class {
  constructor(bundle) {
    this.version = 2;
    if (!bundle.identityKey) {
      throw new Error("missing identity key");
    }
    this.identityKey = new SignedPrivateKey(bundle.identityKey);
    this.preKeys = (bundle.preKeys || []).map((k) => new SignedPrivateKey(k));
  }
  // Generate a new key bundle with the preKey signed byt the identityKey.
  // Optionally sign the identityKey with the provided wallet as well.
  static async generate(wallet) {
    const identityKey = await SignedPrivateKey.generate(
      new WalletSigner(wallet)
    );
    const bundle = new PrivateKeyBundleV2({
      identityKey,
      preKeys: []
    });
    await bundle.addPreKey();
    return bundle;
  }
  // Return the current (latest) pre-key (to be advertised).
  getCurrentPreKey() {
    return this.preKeys[0];
  }
  // Find pre-key matching the provided public key.
  findPreKey(which) {
    const preKey = this.preKeys.find((key) => key.matches(which));
    if (!preKey) {
      throw new NoMatchingPreKeyError(which);
    }
    return preKey;
  }
  // Generate a new pre-key to be used as the current pre-key.
  async addPreKey() {
    this._publicKeyBundle = void 0;
    const preKey = await SignedPrivateKey.generate(this.identityKey);
    this.preKeys.unshift(preKey);
  }
  // Return a key bundle with the current pre-key.
  getPublicKeyBundle() {
    if (!this._publicKeyBundle) {
      this._publicKeyBundle = new SignedPublicKeyBundle({
        identityKey: this.identityKey.publicKey,
        preKey: this.getCurrentPreKey().publicKey
      });
    }
    return this._publicKeyBundle;
  }
  // sharedSecret derives a secret from peer's key bundles using a variation of X3DH protocol
  // where the sender's ephemeral key pair is replaced by the sender's pre-key.
  // @peer is the peer's public key bundle
  // @myPreKey indicates which of my preKeys should be used to derive the secret
  // @recipient indicates if this is the sending or receiving side.
  async sharedSecret(peer, myPreKey, isRecipient) {
    if (!peer.identityKey || !peer.preKey) {
      throw new Error("invalid peer key bundle");
    }
    if (!await peer.identityKey.verifyKey(peer.preKey)) {
      throw new Error("peer preKey signature invalid");
    }
    if (!this.identityKey) {
      throw new Error("missing identity key");
    }
    let dh1, dh2, preKey;
    if (isRecipient) {
      preKey = this.findPreKey(myPreKey);
      dh1 = preKey.sharedSecret(peer.identityKey);
      dh2 = this.identityKey.sharedSecret(peer.preKey);
    } else {
      preKey = this.findPreKey(myPreKey);
      dh1 = this.identityKey.sharedSecret(peer.preKey);
      dh2 = preKey.sharedSecret(peer.identityKey);
    }
    const dh3 = preKey.sharedSecret(peer.preKey);
    const secret = new Uint8Array(dh1.length + dh2.length + dh3.length);
    secret.set(dh1, 0);
    secret.set(dh2, dh1.length);
    secret.set(dh3, dh1.length + dh2.length);
    return secret;
  }
  encode() {
    return privateKey.PrivateKeyBundle.encode({
      v1: void 0,
      v2: this
    }).finish();
  }
  equals(other) {
    if (this.preKeys.length !== other.preKeys.length) {
      return false;
    }
    for (let i = 0; i < this.preKeys.length; i++) {
      if (!this.preKeys[i].equals(other.preKeys[i])) {
        return false;
      }
    }
    return this.identityKey.equals(other.identityKey);
  }
  static fromLegacyBundle(bundle) {
    return new PrivateKeyBundleV2({
      identityKey: SignedPrivateKey.fromLegacyKey(bundle.identityKey, true),
      preKeys: bundle.preKeys.map(
        (k) => SignedPrivateKey.fromLegacyKey(k)
      )
    });
  }
};
var PrivateKeyBundleV1 = class {
  constructor(bundle) {
    this.version = 1;
    if (!bundle.identityKey) {
      throw new Error("missing identity key");
    }
    this.identityKey = new PrivateKey(bundle.identityKey);
    this.preKeys = (bundle.preKeys || []).map((k) => new PrivateKey(k));
  }
  // Generate a new key bundle with the preKey signed byt the identityKey.
  // Optionally sign the identityKey with the provided wallet as well.
  static async generate(wallet) {
    const identityKey = PrivateKey.generate();
    if (wallet) {
      await identityKey.publicKey.signWithWallet(wallet);
    }
    const bundle = new PrivateKeyBundleV1({
      identityKey,
      preKeys: []
    });
    await bundle.addPreKey();
    return bundle;
  }
  // Return the current (latest) pre-key (to be advertised).
  getCurrentPreKey() {
    return this.preKeys[0];
  }
  // Find pre-key matching the provided public key.
  findPreKey(which) {
    const preKey = this.preKeys.find((key) => key.matches(which));
    if (!preKey) {
      throw new NoMatchingPreKeyError(which);
    }
    return preKey;
  }
  // Generate a new pre-key to be used as the current pre-key.
  async addPreKey() {
    this._publicKeyBundle = void 0;
    const preKey = PrivateKey.generate();
    await this.identityKey.signKey(preKey.publicKey);
    this.preKeys.unshift(preKey);
  }
  // Return a key bundle with the current pre-key.
  getPublicKeyBundle() {
    if (!this._publicKeyBundle) {
      this._publicKeyBundle = new PublicKeyBundle({
        identityKey: this.identityKey.publicKey,
        preKey: this.getCurrentPreKey().publicKey
      });
    }
    return this._publicKeyBundle;
  }
  // sharedSecret derives a secret from peer's key bundles using a variation of X3DH protocol
  // where the sender's ephemeral key pair is replaced by the sender's pre-key.
  // @peer is the peer's public key bundle
  // @myPreKey indicates which of my preKeys should be used to derive the secret
  // @recipient indicates if this is the sending or receiving side.
  async sharedSecret(peer, myPreKey, isRecipient) {
    if (!peer.identityKey || !peer.preKey) {
      throw new Error("invalid peer key bundle");
    }
    if (!await peer.identityKey.verifyKey(peer.preKey)) {
      throw new Error("peer preKey signature invalid");
    }
    if (!this.identityKey) {
      throw new Error("missing identity key");
    }
    let dh1, dh2, preKey;
    if (isRecipient) {
      preKey = this.findPreKey(myPreKey);
      dh1 = preKey.sharedSecret(peer.identityKey);
      dh2 = this.identityKey.sharedSecret(peer.preKey);
    } else {
      preKey = this.findPreKey(myPreKey);
      dh1 = this.identityKey.sharedSecret(peer.preKey);
      dh2 = preKey.sharedSecret(peer.identityKey);
    }
    const dh3 = preKey.sharedSecret(peer.preKey);
    const secret = new Uint8Array(dh1.length + dh2.length + dh3.length);
    secret.set(dh1, 0);
    secret.set(dh2, dh1.length);
    secret.set(dh3, dh1.length + dh2.length);
    return secret;
  }
  encode() {
    return privateKey.PrivateKeyBundle.encode({
      v1: this,
      v2: void 0
    }).finish();
  }
};
function decodePrivateKeyBundle(bytes) {
  const b = privateKey.PrivateKeyBundle.decode(bytes);
  if (b.v1) {
    return new PrivateKeyBundleV1(b.v1);
  }
  if (b.v2) {
    return new PrivateKeyBundleV2(b.v2);
  }
  throw new Error("unknown private key bundle version");
}
var IV_LENGTH = 16;
var EPHEMERAL_PUBLIC_KEY_LENGTH = 65;
var MAC_LENGTH = 32;
var AES_BLOCK_SIZE = 16;
var assertEciesLengths = (ecies) => {
  if (ecies.iv.length !== IV_LENGTH) {
    throw new Error("Invalid iv length");
  }
  if (ecies.ephemeralPublicKey.length !== EPHEMERAL_PUBLIC_KEY_LENGTH) {
    throw new Error("Invalid ephemPublicKey length");
  }
  if (ecies.ciphertext.length < 1 || ecies.ciphertext.length % AES_BLOCK_SIZE !== 0) {
    throw new Error("Invalid ciphertext length");
  }
  if (ecies.mac.length !== MAC_LENGTH) {
    throw new Error("Invalid mac length");
  }
};
var SignedEciesCiphertext = class {
  constructor({ eciesBytes, signature: signature5 }) {
    if (!eciesBytes || !eciesBytes.length) {
      throw new Error("eciesBytes is empty");
    }
    if (!signature5) {
      throw new Error("signature is undefined");
    }
    this.eciesBytes = eciesBytes;
    this.signature = new Signature(signature5);
    this.ciphertext = ciphertext.SignedEciesCiphertext_Ecies.decode(eciesBytes);
  }
  toBytes() {
    return ciphertext.SignedEciesCiphertext.encode(this).finish();
  }
  async verify(pubKey) {
    return pubKey.verify(this.signature, await sha256(this.eciesBytes));
  }
  static fromBytes(data) {
    const obj = ciphertext.SignedEciesCiphertext.decode(data);
    return new SignedEciesCiphertext(obj);
  }
  static async create(ecies, signer) {
    assertEciesLengths(ecies);
    const eciesBytes = ciphertext.SignedEciesCiphertext_Ecies.encode(ecies).finish();
    const signature5 = await signer.sign(await sha256(eciesBytes));
    return new SignedEciesCiphertext({ eciesBytes, signature: signature5 });
  }
};

// src/PreparedMessage.ts
var PreparedMessage = class {
  constructor(messageEnvelope, onSend) {
    this.messageEnvelope = messageEnvelope;
    this.onSend = onSend;
  }
  async messageID() {
    if (!this.messageEnvelope.message) {
      throw new Error("no envelope message");
    }
    return bytesToHex(await sha256(this.messageEnvelope.message));
  }
  async send() {
    await this.onSend();
  }
};

// src/keystore/errors.ts
var KeystoreError = class extends Error {
  constructor(code, message2) {
    super(message2);
    this.code = code;
  }
};

// src/utils/keystore.ts
var getResultOrThrow = (response) => {
  if (response.error) {
    throw new KeystoreError(response.error.code, response.error.message);
  }
  if (!response.result) {
    throw new KeystoreError(
      keystore.ErrorCode.ERROR_CODE_UNSPECIFIED,
      "No result from Keystore"
    );
  }
  if ("encrypted" in response.result && !response.result.encrypted) {
    throw new Error("Missing ciphertext");
  }
  if ("decrypted" in response.result && !response.result.decrypted) {
    throw new Error("Missing decrypted result");
  }
  return response.result;
};
var buildDecryptV1Request = (messages, myPublicKeyBundle) => {
  return {
    requests: messages.map((m) => {
      const sender = new PublicKeyBundle({
        identityKey: m.header.sender?.identityKey,
        preKey: m.header.sender?.preKey
      });
      const isSender = myPublicKeyBundle.equals(sender);
      return {
        payload: m.ciphertext,
        peerKeys: isSender ? new PublicKeyBundle({
          identityKey: m.header.recipient?.identityKey,
          preKey: m.header.recipient?.preKey
        }) : sender,
        headerBytes: m.headerBytes,
        isSender
      };
    })
  };
};

// src/MessageContent.ts
var ContentTypeId = class {
  constructor(obj) {
    this.authorityId = obj.authorityId;
    this.typeId = obj.typeId;
    this.versionMajor = obj.versionMajor;
    this.versionMinor = obj.versionMinor;
  }
  toString() {
    return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`;
  }
  sameAs(id) {
    return this.authorityId === id.authorityId && this.typeId === id.typeId;
  }
};
var ContentTypeFallback = new ContentTypeId({
  authorityId: "xmtp.org",
  typeId: "fallback",
  versionMajor: 1,
  versionMinor: 0
});

// src/codecs/Text.ts
var ContentTypeText = new ContentTypeId({
  authorityId: "xmtp.org",
  typeId: "text",
  versionMajor: 1,
  versionMinor: 0
});
var TextCodec = class {
  get contentType() {
    return ContentTypeText;
  }
  encode(content) {
    return {
      type: ContentTypeText,
      parameters: { encoding: "UTF-8" /* utf8 */ },
      content: new TextEncoder().encode(content)
    };
  }
  decode(content) {
    const encoding = content.parameters.encoding;
    if (encoding && encoding !== "UTF-8" /* utf8 */) {
      throw new Error(`unrecognized encoding ${encoding}`);
    }
    return new TextDecoder().decode(content.content);
  }
};

// src/conversations/Conversation.ts
var ConversationV1 = class {
  constructor(client, address, createdAt) {
    this.context = void 0;
    this.peerAddress = utils.getAddress(address);
    this.client = client;
    this.createdAt = createdAt;
  }
  get clientAddress() {
    return this.client.address;
  }
  get topic() {
    return buildDirectMessageTopic(this.peerAddress, this.client.address);
  }
  get ephemeralTopic() {
    return buildDirectMessageTopic(
      this.peerAddress,
      this.client.address
    ).replace("/xmtp/0/dm-", "/xmtp/0/dmE-");
  }
  /**
   * Returns a list of all messages to/from the peerAddress
   */
  async messages(opts) {
    const topic = buildDirectMessageTopic(this.peerAddress, this.client.address);
    const messages = await this.client.listEnvelopes(
      topic,
      this.processEnvelope.bind(this),
      opts
    );
    return this.decryptBatch(messages, topic, false);
  }
  messagesPaginated(opts) {
    return this.client.listEnvelopesPaginated(
      this.topic,
      // This won't be performant once we start supporting a remote keystore
      // TODO: Either better batch support or we ditch this under-utilized feature
      this.decodeMessage.bind(this),
      opts
    );
  }
  // decodeMessage takes an envelope and either returns a `DecodedMessage` or throws if an error occurs
  async decodeMessage(env) {
    if (!env.contentTopic) {
      throw new Error("Missing content topic");
    }
    const msg = await this.processEnvelope(env);
    const decryptResults = await this.decryptBatch(
      [msg],
      env.contentTopic,
      true
    );
    if (!decryptResults.length) {
      throw new Error("No results");
    }
    return decryptResults[0];
  }
  async prepareMessage(content, options) {
    let topics;
    let recipient = await this.client.getUserContact(this.peerAddress);
    if (!recipient) {
      throw new Error(`recipient ${this.peerAddress} is not registered`);
    }
    if (!(recipient instanceof PublicKeyBundle)) {
      recipient = recipient.toLegacyBundle();
    }
    if (!this.client.contacts.has(this.peerAddress)) {
      topics = [
        buildUserIntroTopic(this.peerAddress),
        buildUserIntroTopic(this.client.address),
        this.topic
      ];
      this.client.contacts.add(this.peerAddress);
    } else {
      topics = [this.topic];
    }
    const payload = await this.client.encodeContent(content, options);
    const msg = await this.createMessage(payload, recipient, options?.timestamp);
    const env = {
      contentTopic: this.topic,
      message: msg.toBytes(),
      timestampNs: toNanoString(msg.sent)
    };
    return new PreparedMessage(env, async () => {
      await this.client.publishEnvelopes(
        topics.map((topic) => ({
          contentTopic: topic,
          message: msg.toBytes(),
          timestamp: msg.sent
        }))
      );
    });
  }
  /**
   * Returns a Stream of any new messages to/from the peerAddress
   */
  streamMessages() {
    return Stream.create(
      this.client,
      [this.topic],
      async (env) => this.decodeMessage(env)
    );
  }
  async processEnvelope({
    message: message2,
    contentTopic
  }) {
    const messageBytes = b64Decode(message2);
    const decoded = await MessageV1.fromBytes(messageBytes);
    const { senderAddress, recipientAddress } = decoded;
    if (!senderAddress || !recipientAddress || !contentTopic || buildDirectMessageTopic(senderAddress, recipientAddress) !== this.topic) {
      throw new Error("Headers do not match intended recipient");
    }
    return decoded;
  }
  streamEphemeral() {
    return Stream.create(
      this.client,
      [this.ephemeralTopic],
      this.decodeMessage.bind(this)
    );
  }
  /**
   * Send a message into the conversation.
   */
  async send(content, options) {
    let topics;
    let recipient = await this.client.getUserContact(this.peerAddress);
    if (!recipient) {
      throw new Error(`recipient ${this.peerAddress} is not registered`);
    }
    if (!(recipient instanceof PublicKeyBundle)) {
      recipient = recipient.toLegacyBundle();
    }
    const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;
    if (!this.client.contacts.has(this.peerAddress)) {
      topics = [
        buildUserIntroTopic(this.peerAddress),
        buildUserIntroTopic(this.client.address),
        topic
      ];
      this.client.contacts.add(this.peerAddress);
    } else {
      topics = [this.topic];
    }
    const contentType = options?.contentType || ContentTypeText;
    const payload = await this.client.encodeContent(content, options);
    const msg = await this.createMessage(payload, recipient, options?.timestamp);
    await this.client.publishEnvelopes(
      topics.map((topic2) => ({
        contentTopic: topic2,
        message: msg.toBytes(),
        timestamp: msg.sent
      }))
    );
    return DecodedMessage.fromV1Message(
      msg,
      content,
      contentType,
      payload,
      topics[0],
      // Just use the first topic for the returned value
      this
    );
  }
  async decryptBatch(messages, topic, throwOnError = false) {
    const responses = (await this.client.keystore.decryptV1(
      buildDecryptV1Request(messages, this.client.publicKeyBundle)
    )).responses;
    const out = [];
    for (let i = 0; i < responses.length; i++) {
      const result = responses[i];
      const message2 = messages[i];
      try {
        const { decrypted } = getResultOrThrow(result);
        out.push(await this.buildDecodedMessage(message2, decrypted, topic));
      } catch (e) {
        if (throwOnError) {
          throw e;
        }
        console.warn("Error decoding content", e);
      }
    }
    return out;
  }
  async buildDecodedMessage(message2, decrypted, topic) {
    const { content, contentType, error } = await decodeContent(
      decrypted,
      this.client
    );
    return DecodedMessage.fromV1Message(
      message2,
      content,
      contentType,
      decrypted,
      topic,
      this,
      error
    );
  }
  async createMessage(payload, recipient, timestamp) {
    timestamp = timestamp || /* @__PURE__ */ new Date();
    return MessageV1.encode(
      this.client.keystore,
      payload,
      this.client.publicKeyBundle,
      recipient,
      timestamp
    );
  }
};
var ConversationV2 = class {
  constructor(client, topic, peerAddress, createdAt, context) {
    this.topic = topic;
    this.createdAt = createdAt;
    this.context = context;
    this.client = client;
    this.peerAddress = peerAddress;
  }
  get clientAddress() {
    return this.client.address;
  }
  /**
   * Returns a list of all messages to/from the peerAddress
   */
  async messages(opts) {
    const messages = await this.client.listEnvelopes(
      this.topic,
      this.processEnvelope.bind(this),
      opts
    );
    return this.decryptBatch(messages, false);
  }
  messagesPaginated(opts) {
    return this.client.listEnvelopesPaginated(
      this.topic,
      this.decodeMessage.bind(this),
      opts
    );
  }
  get ephemeralTopic() {
    return this.topic.replace("/xmtp/0/m", "/xmtp/0/mE");
  }
  streamEphemeral() {
    return Stream.create(
      this.client,
      [this.ephemeralTopic],
      this.decodeMessage.bind(this)
    );
  }
  /**
   * Returns a Stream of any new messages to/from the peerAddress
   */
  streamMessages() {
    return Stream.create(
      this.client,
      [this.topic],
      this.decodeMessage.bind(this)
    );
  }
  /**
   * Send a message into the conversation
   */
  async send(content, options) {
    const payload = await this.client.encodeContent(content, options);
    const msg = await this.createMessage(payload, options?.timestamp);
    let topic;
    if (options?.ephemeral) {
      topic = this.ephemeralTopic;
    } else {
      topic = this.topic;
    }
    await this.client.publishEnvelopes([
      {
        contentTopic: topic,
        message: msg.toBytes(),
        timestamp: msg.sent
      }
    ]);
    const contentType = options?.contentType || ContentTypeText;
    return DecodedMessage.fromV2Message(
      msg,
      content,
      contentType,
      this.topic,
      payload,
      this,
      this.client.address
    );
  }
  async createMessage(payload, timestamp) {
    const header = {
      topic: this.topic,
      createdNs: dateToNs(timestamp || /* @__PURE__ */ new Date())
    };
    const headerBytes = message.MessageHeaderV2.encode(header).finish();
    const digest = await sha256(concat(headerBytes, payload));
    const signed = {
      payload,
      sender: this.client.signedPublicKeyBundle,
      signature: await this.client.keystore.signDigest({
        digest,
        prekeyIndex: 0,
        identityKey: void 0
      })
    };
    const signedBytes = content.SignedContent.encode(signed).finish();
    const ciphertext4 = await this.encryptMessage(signedBytes, headerBytes);
    const protoMsg = {
      v1: void 0,
      v2: { headerBytes, ciphertext: ciphertext4 }
    };
    const bytes = message.Message.encode(protoMsg).finish();
    return MessageV2.create(protoMsg, header, bytes);
  }
  async decryptBatch(messages, throwOnError = false) {
    const responses = (await this.client.keystore.decryptV2(this.buildDecryptRequest(messages))).responses;
    const out = [];
    for (let i = 0; i < responses.length; i++) {
      const result = responses[i];
      const message2 = messages[i];
      try {
        const { decrypted } = getResultOrThrow(result);
        out.push(await this.buildDecodedMessage(message2, decrypted));
      } catch (e) {
        if (throwOnError) {
          throw e;
        }
        console.warn("Error decoding content", e);
      }
    }
    return out;
  }
  buildDecryptRequest(messages) {
    return {
      requests: messages.map((m) => {
        return {
          payload: m.ciphertext,
          headerBytes: m.headerBytes,
          contentTopic: this.topic
        };
      })
    };
  }
  async encryptMessage(payload, headerBytes) {
    const { responses } = await this.client.keystore.encryptV2({
      requests: [
        {
          payload,
          headerBytes,
          contentTopic: this.topic
        }
      ]
    });
    if (responses.length !== 1) {
      throw new Error("Invalid response length");
    }
    const { encrypted } = getResultOrThrow(responses[0]);
    return encrypted;
  }
  async buildDecodedMessage(msg, decrypted) {
    const signed = content.SignedContent.decode(decrypted);
    if (!signed.sender?.identityKey || !signed.sender?.preKey || !signed.signature) {
      throw new Error("incomplete signed content");
    }
    await validatePrekeys(signed);
    const digest = await sha256(concat(msg.headerBytes, signed.payload));
    if (!new SignedPublicKey(signed.sender?.preKey).verify(
      new Signature(signed.signature),
      digest
    )) {
      throw new Error("invalid signature");
    }
    const senderAddress = await new SignedPublicKeyBundle(
      signed.sender
    ).walletSignatureAddress();
    const { content: content$1, contentType, error } = await decodeContent(
      signed.payload,
      this.client
    );
    return DecodedMessage.fromV2Message(
      msg,
      content$1,
      contentType,
      this.topic,
      signed.payload,
      this,
      senderAddress,
      error
    );
  }
  async prepareMessage(content, options) {
    const payload = await this.client.encodeContent(content, options);
    const msg = await this.createMessage(payload, options?.timestamp);
    const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;
    const env = {
      contentTopic: topic,
      message: msg.toBytes(),
      timestampNs: toNanoString(msg.sent)
    };
    return new PreparedMessage(env, async () => {
      await this.client.publishEnvelopes([
        {
          contentTopic: this.topic,
          message: msg.toBytes(),
          timestamp: msg.sent
        }
      ]);
    });
  }
  async processEnvelope(env) {
    if (!env.message || !env.contentTopic) {
      throw new Error("empty envelope");
    }
    const messageBytes = b64Decode(env.message.toString());
    const msg = message.Message.decode(messageBytes);
    if (!msg.v2) {
      throw new Error("unknown message version");
    }
    const header = message.MessageHeaderV2.decode(msg.v2.headerBytes);
    if (header.topic !== this.topic) {
      throw new Error("topic mismatch");
    }
    return MessageV2.create(msg, header, messageBytes);
  }
  async decodeMessage(env) {
    if (!env.contentTopic) {
      throw new Error("Missing content topic");
    }
    const msg = await this.processEnvelope(env);
    const decryptResults = await this.decryptBatch([msg], true);
    if (!decryptResults.length) {
      throw new Error("No results");
    }
    return decryptResults[0];
  }
};
async function validatePrekeys(signed) {
  const senderPreKey = signed.sender?.preKey;
  if (!senderPreKey || !senderPreKey.signature || !senderPreKey.keyBytes) {
    throw new Error("missing pre-key or pre-key signature");
  }
  const senderIdentityKey = signed.sender?.identityKey;
  if (!senderIdentityKey) {
    throw new Error("missing identity key in bundle");
  }
  const isValidPrekey = await new SignedPublicKey(senderIdentityKey).verifyKey(
    new SignedPublicKey(senderPreKey)
  );
  if (!isValidPrekey) {
    throw new Error("pre key not signed by identity key");
  }
}
async function decompress(encoded, maxSize) {
  if (encoded.compression === void 0) {
    return;
  }
  const sink = { bytes: new Uint8Array(encoded.content.length) };
  await readStreamFromBytes(encoded.content).pipeThrough(
    new DecompressionStream(compressionIdFromCode(encoded.compression))
  ).pipeTo(writeStreamToBytes(sink, maxSize));
  encoded.content = sink.bytes;
}
async function compress(encoded) {
  if (encoded.compression === void 0) {
    return;
  }
  const sink = { bytes: new Uint8Array(encoded.content.length / 10) };
  await readStreamFromBytes(encoded.content).pipeThrough(
    new CompressionStream(compressionIdFromCode(encoded.compression))
  ).pipeTo(writeStreamToBytes(sink, encoded.content.length + 1e3));
  encoded.content = sink.bytes;
}
function compressionIdFromCode(code) {
  if (code === content.Compression.COMPRESSION_GZIP) {
    return "gzip";
  }
  if (code === content.Compression.COMPRESSION_DEFLATE) {
    return "deflate";
  }
  throw new Error("unrecognized compression algorithm");
}
function readStreamFromBytes(bytes, chunkSize = 1024) {
  let position = 0;
  return new ReadableStream({
    pull(controller) {
      if (position >= bytes.length) {
        return controller.close();
      }
      let end = position + chunkSize;
      end = end <= bytes.length ? end : bytes.length;
      controller.enqueue(bytes.subarray(position, end));
      position = end;
    }
  });
}
function writeStreamToBytes(sink, maxSize) {
  let position = 0;
  return new WritableStream({
    write(chunk) {
      const end = position + chunk.length;
      if (end > maxSize) {
        throw new Error("maximum output size exceeded");
      }
      while (sink.bytes.length < end) {
        sink.bytes = growBytes(sink.bytes, maxSize);
      }
      sink.bytes.set(chunk, position);
      position = end;
    },
    close() {
      if (position < sink.bytes.length) {
        sink.bytes = sink.bytes.subarray(0, position);
      }
    }
  });
}
function growBytes(bytes, maxSize) {
  let newSize = bytes.length * 2;
  if (newSize > maxSize) {
    newSize = maxSize;
  }
  const bigger = new Uint8Array(newSize);
  bigger.set(bytes);
  return bigger;
}

// src/Message.ts
var headerBytesAndCiphertext = (msg) => {
  if (msg.v1?.ciphertext) {
    return [msg.v1.headerBytes, new Ciphertext(msg.v1.ciphertext)];
  }
  if (msg.v2?.ciphertext) {
    return [msg.v2.headerBytes, new Ciphertext(msg.v2.ciphertext)];
  }
  throw new Error("unknown message version");
};
var MessageBase = class {
  constructor(id, bytes, obj) {
    [this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj);
    this.id = id;
    this.bytes = bytes;
  }
  toBytes() {
    return this.bytes;
  }
};
var MessageV1 = class extends MessageBase {
  constructor(id, bytes, obj, header, senderAddress) {
    super(id, bytes, obj);
    this.conversation = void 0;
    this.senderAddress = senderAddress;
    this.header = header;
  }
  static async create(obj, header, bytes) {
    if (!header.sender) {
      throw new Error("missing message sender");
    }
    const senderAddress = new PublicKeyBundle(
      header.sender
    ).walletSignatureAddress();
    const id = bytesToHex(await sha256(bytes));
    return new MessageV1(id, bytes, obj, header, senderAddress);
  }
  get sent() {
    return new Date(this.header.timestamp.toNumber());
  }
  // wallet address derived from the signature of the message recipient
  get recipientAddress() {
    if (!this.header?.recipient?.identityKey) {
      return void 0;
    }
    return new PublicKey(
      this.header.recipient.identityKey
    ).walletSignatureAddress();
  }
  async decrypt(keystore6, myPublicKeyBundle) {
    const responses = (await keystore6.decryptV1(buildDecryptV1Request([this], myPublicKeyBundle))).responses;
    if (!responses.length) {
      throw new Error("No response from Keystore");
    }
    const { decrypted } = getResultOrThrow(responses[0]);
    return decrypted;
  }
  static fromBytes(bytes) {
    const message2 = message.Message.decode(bytes);
    const [headerBytes] = headerBytesAndCiphertext(message2);
    const header = message.MessageHeaderV1.decode(headerBytes);
    if (!header) {
      throw new Error("missing message header");
    }
    if (!header.sender) {
      throw new Error("missing message sender");
    }
    if (!header.sender.identityKey) {
      throw new Error("missing message sender identity key");
    }
    if (!header.sender.preKey) {
      throw new Error("missing message sender pre-key");
    }
    if (!header.recipient) {
      throw new Error("missing message recipient");
    }
    if (!header.recipient.identityKey) {
      throw new Error("missing message recipient identity-key");
    }
    if (!header.recipient.preKey) {
      throw new Error("missing message recipient pre-key");
    }
    return MessageV1.create(message2, header, bytes);
  }
  static async encode(keystore6, payload, sender, recipient, timestamp) {
    const header = {
      sender,
      recipient,
      timestamp: Long.fromNumber(timestamp.getTime())
    };
    const headerBytes = message.MessageHeaderV1.encode(header).finish();
    const results = await keystore6.encryptV1({
      requests: [
        {
          recipient,
          headerBytes,
          payload
        }
      ]
    });
    if (!results.responses.length) {
      throw new Error("No response from Keystore");
    }
    const { encrypted: ciphertext4 } = getResultOrThrow(results.responses[0]);
    const protoMsg = {
      v1: { headerBytes, ciphertext: ciphertext4 },
      v2: void 0
    };
    const bytes = message.Message.encode(protoMsg).finish();
    return MessageV1.create(protoMsg, header, bytes);
  }
};
var MessageV2 = class extends MessageBase {
  // eslint-disable-line camelcase
  constructor(id, bytes, obj, header) {
    super(id, bytes, obj);
    this.header = header;
  }
  static async create(obj, header, bytes) {
    const id = bytesToHex(await sha256(bytes));
    return new MessageV2(id, bytes, obj, header);
  }
  get sent() {
    return nsToDate(this.header.createdNs);
  }
};
var DecodedMessage = class {
  constructor({
    id,
    messageVersion,
    senderAddress,
    recipientAddress,
    conversation,
    contentBytes,
    contentType,
    contentTopic,
    content,
    sent,
    error
  }) {
    this.id = id;
    this.messageVersion = messageVersion;
    this.senderAddress = senderAddress;
    this.recipientAddress = recipientAddress;
    this.conversation = conversation;
    this.contentType = contentType;
    this.sent = sent;
    this.error = error;
    this.content = content;
    this.contentTopic = contentTopic;
    this.contentBytes = contentBytes;
  }
  toBytes() {
    return message.DecodedMessage.encode({
      ...this,
      conversation: {
        topic: this.conversation.topic,
        context: this.conversation.context ?? void 0,
        createdNs: dateToNs(this.conversation.createdAt),
        peerAddress: this.conversation.peerAddress
      },
      sentNs: dateToNs(this.sent)
    }).finish();
  }
  static async fromBytes(data, client) {
    const protoVal = message.DecodedMessage.decode(data);
    const messageVersion = protoVal.messageVersion;
    if (messageVersion !== "v1" && messageVersion !== "v2") {
      throw new Error("Invalid message version");
    }
    if (!protoVal.conversation) {
      throw new Error("No conversation reference found");
    }
    const { content, contentType, error } = await decodeContent(
      protoVal.contentBytes,
      client
    );
    return new DecodedMessage({
      ...protoVal,
      content,
      contentType,
      error,
      messageVersion,
      sent: nsToDate(protoVal.sentNs),
      conversation: conversationReferenceToConversation(
        protoVal.conversation,
        client,
        messageVersion
      )
    });
  }
  static fromV1Message(message2, content, contentType, contentBytes, contentTopic, conversation, error) {
    const { id, senderAddress, recipientAddress, sent } = message2;
    if (!senderAddress) {
      throw new Error("Sender address is required");
    }
    return new DecodedMessage({
      id,
      messageVersion: "v1",
      senderAddress,
      recipientAddress,
      sent,
      content,
      contentBytes,
      contentType,
      contentTopic,
      conversation,
      error
    });
  }
  static fromV2Message(message2, content, contentType, contentTopic, contentBytes, conversation, senderAddress, error) {
    const { id, sent } = message2;
    return new DecodedMessage({
      id,
      messageVersion: "v2",
      senderAddress,
      sent,
      content,
      contentBytes,
      contentType,
      contentTopic,
      conversation,
      error
    });
  }
};
async function decodeContent(contentBytes, client) {
  const encodedContent = content.EncodedContent.decode(contentBytes);
  if (!encodedContent.type) {
    throw new Error("missing content type");
  }
  let content$1;
  let contentType = new ContentTypeId(encodedContent.type);
  let error;
  await decompress(encodedContent, 1e3);
  const codec = client.codecFor(contentType);
  if (codec) {
    content$1 = codec.decode(encodedContent, client);
  } else {
    error = new Error("unknown content type " + contentType);
    if (encodedContent.fallback) {
      content$1 = encodedContent.fallback;
      contentType = ContentTypeFallback;
    }
  }
  return { content: content$1, contentType, error };
}
function conversationReferenceToConversation(reference, client, version) {
  if (version === "v1") {
    return new ConversationV1(
      client,
      reference.peerAddress,
      nsToDate(reference.createdNs)
    );
  }
  if (version === "v2") {
    return new ConversationV2(
      client,
      reference.topic,
      reference.peerAddress,
      nsToDate(reference.createdNs),
      reference.context
    );
  }
  throw new Error(`Unknown conversation version ${version}`);
}

// src/authn/AuthCache.ts
var DEFAULT_MAX_AGE_SECONDS = 60 * 60 - 10;
var AuthCache = class {
  constructor(authenticator, cacheExpirySeconds = DEFAULT_MAX_AGE_SECONDS) {
    this.authenticator = authenticator;
    this.maxAgeMs = cacheExpirySeconds * 1e3;
  }
  async getToken() {
    if (!this.token || this.token.ageMs > this.maxAgeMs) {
      await this.refresh();
    }
    return this.token.toBase64();
  }
  async refresh() {
    this.token = await this.authenticator.createToken();
  }
};

// package.json
var package_default = {
  name: "@xmtp/xmtp-js",
  version: "9.1.6",
  description: "XMTP client SDK for interacting with XMTP networks.",
  type: "module",
  main: "dist/index.cjs",
  module: "dist/index.js",
  types: "dist/index.d.ts",
  browser: "dist/web/index.js",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      browser: "./dist/web/index.js",
      import: "./dist/index.js",
      require: "./dist/index.cjs"
    }
  },
  scripts: {
    prebench: "npm run build:bench",
    bench: "node dist/bench/index.cjs",
    build: "npm run clean:dist && npm run build:node && npm run build:web",
    "build:bench": "tsup --out-dir dist/bench --entry.0 bench/index.ts --format cjs",
    "build:node": "tsup",
    "build:web": "tsup --platform browser --target esnext",
    "build:docs": "rimraf docs && mkdir -p tmp && cp README.md tmp/ && sed -i.bak '/badge.svg/d' tmp/README.md && typedoc --excludePrivate --readme tmp/README.md src/index.ts",
    clean: "npm run clean:dist && npm run clean:proto",
    "clean:dist": "rimraf dist",
    "clean:proto": "rimraf -g src/proto/*.ts",
    package: "npm pack",
    prepublishOnly: "npm run build",
    "test:setup": "./dev/up",
    "test:teardown": "./dev/down",
    test: "npm run test:node",
    "test:node": "jest --no-cache --env='node' --testTimeout=30000",
    "test:jsdom": "jest --no-cache --env='./jest.jsdom.env.cjs' --testTimeout=30000",
    "test:cov": "jest --coverage --no-cache --runInBand",
    lint: "prettier --check . && eslint .",
    autolint: "prettier --write . && eslint --fix .",
    "semantic-release": "semantic-release"
  },
  publishConfig: {
    access: "public",
    provenance: true
  },
  files: [
    "dist/index.cjs",
    "dist/index.cjs.map",
    "dist/index.d.ts",
    "dist/index.js",
    "dist/index.js.map",
    "dist/web/index.js",
    "dist/web/index.js.map"
  ],
  keywords: [
    "xmtp",
    "messaging",
    "web3",
    "sdk",
    "js",
    "javascript",
    "node",
    "nodejs"
  ],
  author: "XMTP Labs <eng@xmtp.com>",
  license: "MIT",
  homepage: "https://github.com/xmtp/xmtp-js",
  repository: {
    type: "git",
    url: "https:git@github.com:xmtp/xmtp-js.git"
  },
  bugs: {
    url: "https://github.com/xmtp/xmtp-js/issues"
  },
  release: {
    branches: [
      "main",
      {
        name: "beta",
        prerelease: true
      }
    ]
  },
  dependencies: {
    "@noble/secp256k1": "^1.5.2",
    "@xmtp/proto": "^3.24.0",
    "async-mutex": "^0.4.0",
    elliptic: "^6.5.4",
    ethers: "^5.5.3",
    long: "^5.2.0"
  },
  devDependencies: {
    "@commitlint/cli": "^16.1.0",
    "@commitlint/config-conventional": "^16.0.0",
    "@types/benchmark": "^2.1.2",
    "@types/bl": "^5.0.2",
    "@types/callback-to-async-iterator": "^1.1.4",
    "@types/elliptic": "^6.4.14",
    "@types/jest": "^28.1.3",
    "@types/node": "^18.14.0",
    "@typescript-eslint/eslint-plugin": "^5.38.0",
    "@typescript-eslint/parser": "^5.38.0",
    benny: "^3.7.1",
    "dd-trace": "^2.12.2",
    esbuild: "^0.17.16",
    "esbuild-plugin-external-global": "^1.0.1",
    eslint: "^8.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-config-standard": "^17.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jsdoc": "^37.9.1",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^4.0.0",
    "eslint-plugin-promise": "^6.0.1",
    husky: "^7.0.4",
    jest: "^28.1.3",
    "jest-environment-jsdom": "^28.1.3",
    prettier: "^2.4.0",
    rimraf: "^5.0.0",
    "semantic-release": "^21.0.3",
    "ts-jest": "^28.0.0",
    "ts-node": "^10.9.1",
    tsup: "^6.7.0",
    typedoc: "^0.22.11",
    typescript: "^4.4.3"
  },
  engines: {
    node: ">=18"
  }
};

// src/constants.ts
var XMTP_DEV_WARNING = `
XX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV 
 XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV 
  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  
 XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   
XX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    

Connected to the XMTP 'dev' network. Use 'production' for production messages.
https://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments
`;

// src/ApiClient.ts
var { MessageApi, SortDirection } = messageApi;
var RETRY_SLEEP_TIME = 100;
var ERR_CODE_UNAUTHENTICATED = 16;
var clientVersionHeaderKey = "X-Client-Version";
var appVersionHeaderKey = "X-App-Version";
var ApiUrls = {
  local: "http://localhost:5555",
  dev: "https://dev.xmtp.network",
  production: "https://production.xmtp.network"
};
var GrpcError = class extends Error {
  constructor(message2, code) {
    super(message2);
    this.code = code;
  }
  static fromObject(err) {
    return new GrpcError(err.message, err.code);
  }
};
var isAbortError = (err) => {
  if (!err) {
    return false;
  }
  if (err.name === "AbortError" || err.message.includes("aborted")) {
    return true;
  }
  return false;
};
var isAuthError = (err) => {
  if (err && "code" in err && err.code === ERR_CODE_UNAUTHENTICATED) {
    return true;
  }
  return false;
};
var isNotAuthError = (err) => !isAuthError(err);
var ApiClient = class {
  constructor(pathPrefix, opts) {
    this.pathPrefix = pathPrefix;
    this.maxRetries = opts?.maxRetries || 5;
    this.appVersion = opts?.appVersion;
    this.version = "xmtp-js/" + package_default.version;
    if (pathPrefix === ApiUrls.dev) {
      console.info(XMTP_DEV_WARNING);
    }
  }
  // Raw method for querying the API
  async _query(req) {
    try {
      return await retry(
        MessageApi.Query,
        [
          req,
          {
            pathPrefix: this.pathPrefix,
            mode: "cors",
            headers: this.headers()
          }
        ],
        this.maxRetries,
        RETRY_SLEEP_TIME
      );
    } catch (e) {
      throw GrpcError.fromObject(e);
    }
  }
  // Raw method for batch-querying the API
  _batchQuery(req) {
    return retry(
      MessageApi.BatchQuery,
      [
        req,
        {
          pathPrefix: this.pathPrefix,
          mode: "cors",
          headers: this.headers()
        }
      ],
      this.maxRetries,
      RETRY_SLEEP_TIME
    );
  }
  // Raw method for publishing to the API
  async _publish(req, attemptNumber = 0) {
    const authToken = await this.getToken();
    const headers = this.headers();
    headers.set("Authorization", `Bearer ${authToken}`);
    try {
      return await retry(
        MessageApi.Publish,
        [
          req,
          {
            pathPrefix: this.pathPrefix,
            mode: "cors",
            headers
          }
        ],
        this.maxRetries,
        RETRY_SLEEP_TIME,
        // Do not retry UnauthenticatedErrors
        isNotAuthError
      );
    } catch (e) {
      if (isNotAuthError(e) || attemptNumber >= 1) {
        throw GrpcError.fromObject(e);
      }
      await this.authCache?.refresh();
      return this._publish(req, attemptNumber + 1);
    }
  }
  // Raw method for subscribing
  _subscribe(req, cb) {
    const abortController = new AbortController();
    const doSubscribe = async () => {
      while (true) {
        const startTime = (/* @__PURE__ */ new Date()).getTime();
        try {
          await MessageApi.Subscribe(req, cb, {
            pathPrefix: this.pathPrefix,
            signal: abortController.signal,
            mode: "cors",
            headers: this.headers()
          });
          if (abortController.signal.aborted) {
            return;
          }
          console.info("Stream connection closed. Resubscribing");
          if ((/* @__PURE__ */ new Date()).getTime() - startTime < 1e3) {
            await sleep(1e3);
          }
        } catch (err) {
          if (isAbortError(err) || abortController.signal.aborted) {
            return;
          }
          console.info(
            "Stream connection closed. Resubscribing",
            err.toString()
          );
          if ((/* @__PURE__ */ new Date()).getTime() - startTime < 1e3) {
            await sleep(1e3);
          }
        }
      }
    };
    doSubscribe();
    return async () => {
      abortController?.abort();
    };
  }
  // Use the Query API to return the full contents of any specified topics
  async query(params, {
    direction = SortDirection.SORT_DIRECTION_ASCENDING,
    limit
  }) {
    const out = [];
    for await (const page of this.queryIteratePages(params, {
      direction,
      // If there is a limit of < 100, use that as the page size. Otherwise use 100 and stop if/when limit reached.
      pageSize: limit && limit < 100 ? limit : 100
    })) {
      for (const envelope of page) {
        out.push(envelope);
        if (limit && out.length === limit) {
          return out;
        }
      }
    }
    return out;
  }
  // Will produce an AsyncGenerator of Envelopes
  // Uses queryStreamPages under the hood
  async *queryIterator(params, options) {
    for await (const page of this.queryIteratePages(params, options)) {
      for (const envelope of page) {
        yield envelope;
      }
    }
  }
  // Creates an async generator that will paginate through the Query API until it reaches the end
  // Will yield each page of results as needed
  async *queryIteratePages({ contentTopic, startTime, endTime }, { direction, pageSize = 10 }) {
    if (!contentTopic || !contentTopic.length) {
      throw new Error("Must specify content topics");
    }
    const startTimeNs = toNanoString(startTime);
    const endTimeNs = toNanoString(endTime);
    let cursor;
    while (true) {
      const pagingInfo = {
        limit: pageSize,
        direction,
        cursor
      };
      const result = await this._query({
        contentTopics: [contentTopic],
        startTimeNs,
        endTimeNs,
        pagingInfo
      });
      if (result.envelopes?.length) {
        yield result.envelopes;
      } else {
        return;
      }
      if (result.pagingInfo?.cursor) {
        cursor = result.pagingInfo?.cursor;
      } else {
        return;
      }
    }
  }
  // Take a list of queries and execute them in batches
  async batchQuery(queries) {
    const BATCH_SIZE = 50;
    const batchRequests = [];
    for (let i = 0; i < queries.length; i += BATCH_SIZE) {
      const queriesInBatch = queries.slice(i, i + BATCH_SIZE);
      const constructedQueries = [];
      for (const queryParams of queriesInBatch) {
        constructedQueries.push({
          contentTopics: [queryParams.contentTopic],
          startTimeNs: toNanoString(queryParams.startTime),
          endTimeNs: toNanoString(queryParams.endTime),
          pagingInfo: {
            limit: queryParams.pageSize || 10,
            direction: queryParams.direction || SortDirection.SORT_DIRECTION_ASCENDING
          }
        });
      }
      const batchQueryRequest = {
        requests: constructedQueries
      };
      batchRequests.push(batchQueryRequest);
    }
    const batchQueryResponses = await Promise.all(
      batchRequests.map(async (batch) => this._batchQuery(batch))
    );
    const allEnvelopes = [];
    for (const batchResponse of batchQueryResponses) {
      if (!batchResponse.responses) {
        throw new Error("BatchQueryResponse missing responses");
      }
      for (const queryResponse of batchResponse.responses) {
        if (queryResponse.envelopes) {
          allEnvelopes.push(queryResponse.envelopes);
        } else {
          allEnvelopes.push([]);
        }
      }
    }
    return allEnvelopes;
  }
  // Publish a message to the network
  // Will convert timestamps to the appropriate format expected by the network
  async publish(messages) {
    const toSend = [];
    for (const { contentTopic, message: message2, timestamp } of messages) {
      if (!contentTopic.length) {
        throw new Error("Content topic cannot be empty string");
      }
      if (!message2.length) {
        throw new Error("0 length messages not allowed");
      }
      const dt = timestamp || /* @__PURE__ */ new Date();
      toSend.push({
        contentTopic,
        timestampNs: toNanoString(dt),
        message: Uint8Array.from(message2)
      });
    }
    return this._publish({ envelopes: toSend });
  }
  // Subscribe to a list of topics.
  // Provided callback function will be called on each new message
  // Returns an unsubscribe function that can be used to end the subscription
  subscribe(params, callback) {
    if (!params.contentTopics.length) {
      throw new Error("Must provide list of contentTopics to subscribe to");
    }
    return this._subscribe(params, callback);
  }
  getToken() {
    if (!this.authCache) {
      throw new Error("AuthCache is not set on API Client");
    }
    return this.authCache.getToken();
  }
  setAuthenticator(authenticator, cacheExpirySeconds) {
    this.authCache = new AuthCache(authenticator, cacheExpirySeconds);
  }
  headers() {
    const headers = new Headers();
    headers.set(clientVersionHeaderKey, this.version);
    if (this.appVersion) {
      headers.set(appVersionHeaderKey, this.appVersion);
    }
    return headers;
  }
};
var CLOCK_SKEW_OFFSET_MS = 1e4;
var messageHasHeaders = (msg) => {
  return Boolean(msg.recipientAddress && msg.senderAddress);
};
var ConversationCache = class {
  constructor() {
    this.conversations = [];
    this.mutex = new Mutex();
    this.seenTopics = /* @__PURE__ */ new Set();
  }
  async load(loader) {
    const release = await this.mutex.acquire();
    try {
      const newConvos = await loader({
        latestSeen: this.latestSeen,
        existing: this.conversations
      });
      for (const convo of newConvos) {
        if (!this.seenTopics.has(convo.topic)) {
          this.seenTopics.add(convo.topic);
          this.conversations.push(convo);
          if (!this.latestSeen || convo.createdAt > this.latestSeen) {
            this.latestSeen = convo.createdAt;
          }
        }
      }
    } finally {
      release();
    }
    return [...this.conversations];
  }
};
var Conversations = class {
  constructor(client) {
    this.client = client;
    this.v1Cache = new ConversationCache();
    this.v2Mutex = new Mutex();
  }
  /**
   * List all conversations with the current wallet found in the network.
   */
  async list() {
    const [v1Convos, v2Convos] = await Promise.all([
      this.listV1Conversations(),
      this.listV2Conversations()
    ]);
    const conversations = v1Convos.concat(v2Convos);
    conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
    return conversations;
  }
  async listV1Conversations() {
    return this.v1Cache.load(async ({ latestSeen }) => {
      const seenPeers = await this.getIntroductionPeers({
        startTime: latestSeen ? new Date(+latestSeen - CLOCK_SKEW_OFFSET_MS) : void 0,
        direction: SortDirection.SORT_DIRECTION_ASCENDING
      });
      return Array.from(seenPeers).map(
        ([peerAddress, sent]) => new ConversationV1(this.client, peerAddress, sent)
      );
    });
  }
  /**
   * List all V2 conversations
   */
  async listV2Conversations() {
    return this.v2Mutex.runExclusive(async () => {
      const existing = await this.getV2ConversationsFromKeystore();
      const latestConversation = existing.reduce(
        (memo, curr) => {
          if (!memo || +curr.createdAt > +memo.createdAt) {
            return curr;
          }
          return memo;
        },
        void 0
      );
      const newConversations = await this.updateV2Conversations(
        latestConversation?.createdAt
      );
      const existingTopics = new Set(existing.map((c) => c.topic));
      for (const convo of newConversations) {
        if (!existingTopics.has(convo.topic)) {
          existing.push(convo);
          existingTopics.add(convo.topic);
        }
      }
      existing.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
      return existing;
    });
  }
  async getV2ConversationsFromKeystore() {
    return (await this.client.keystore.getV2Conversations()).map(
      this.conversationReferenceToV2.bind(this)
    );
  }
  // Called in listV2Conversations and in newConversation
  async updateV2Conversations(startTime) {
    const envelopes = await this.client.listInvitations({
      startTime: startTime ? new Date(+startTime - CLOCK_SKEW_OFFSET_MS) : void 0,
      direction: SortDirection.SORT_DIRECTION_ASCENDING
    });
    return this.decodeInvites(envelopes);
  }
  async decodeInvites(envelopes, shouldThrow = false) {
    const { responses } = await this.client.keystore.saveInvites({
      requests: envelopes.map((env) => ({
        payload: b64Decode(env.message),
        timestampNs: Long.fromString(env.timestampNs),
        contentTopic: env.contentTopic
      }))
    });
    const out = [];
    for (const response of responses) {
      try {
        const convo = this.saveInviteResponseToConversation(response);
        out.push(convo);
      } catch (e) {
        console.warn("Error saving invite response to conversation: ", e);
        if (shouldThrow) {
          throw e;
        }
      }
    }
    return out;
  }
  saveInviteResponseToConversation({
    result,
    error
  }) {
    if (error || !result || !result.conversation) {
      throw new Error(`Error from keystore: ${error?.code} ${error?.message}}`);
    }
    return this.conversationReferenceToV2(result.conversation);
  }
  conversationReferenceToV2(convoRef) {
    return new ConversationV2(
      this.client,
      convoRef.topic,
      convoRef.peerAddress,
      nsToDate(convoRef.createdNs),
      convoRef.context
    );
  }
  /**
   * Returns a stream of any newly created conversations.
   * Will dedupe to not return the same conversation twice in the same stream.
   * Does not dedupe any other previously seen conversations
   */
  async stream() {
    const seenPeers = /* @__PURE__ */ new Set();
    const introTopic = buildUserIntroTopic(this.client.address);
    const inviteTopic = buildUserInviteTopic(this.client.address);
    const newPeer = (peerAddress) => {
      if (seenPeers.has(peerAddress)) {
        return false;
      }
      seenPeers.add(peerAddress);
      return true;
    };
    const decodeConversation = async (env) => {
      if (env.contentTopic === introTopic) {
        const messageBytes = b64Decode(env.message);
        const msg = await MessageV1.fromBytes(messageBytes);
        const peerAddress = this.getPeerAddress(msg);
        if (!newPeer(peerAddress)) {
          return void 0;
        }
        await msg.decrypt(this.client.keystore, this.client.publicKeyBundle);
        return new ConversationV1(this.client, peerAddress, msg.sent);
      }
      if (env.contentTopic === inviteTopic) {
        const results = await this.decodeInvites([env], true);
        if (results.length) {
          return results[0];
        }
      }
      throw new Error("unrecognized invite topic");
    };
    return Stream.create(
      this.client,
      [inviteTopic, introTopic],
      decodeConversation.bind(this)
    );
  }
  /**
   * Streams messages from all conversations.
   *
   * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
   * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
   *
   */
  async streamAllMessages() {
    const introTopic = buildUserIntroTopic(this.client.address);
    const inviteTopic = buildUserInviteTopic(this.client.address);
    const topics = /* @__PURE__ */ new Set([introTopic, inviteTopic]);
    const convoMap = /* @__PURE__ */ new Map();
    for (const conversation of await this.list()) {
      topics.add(conversation.topic);
      convoMap.set(conversation.topic, conversation);
    }
    const decodeMessage = async (env) => {
      const contentTopic = env.contentTopic;
      if (!contentTopic) {
        return null;
      }
      if (contentTopic === introTopic) {
        const messageBytes = b64Decode(env.message);
        const msg = await MessageV1.fromBytes(messageBytes);
        if (!messageHasHeaders(msg)) {
          return null;
        }
        const peerAddress = this.getPeerAddress(msg);
        const convo2 = new ConversationV1(
          this.client,
          peerAddress,
          msg.sent
        );
        return convo2.decodeMessage(env);
      }
      if (contentTopic === inviteTopic) {
        const results = await this.decodeInvites([env], true);
        return results[0];
      }
      const convo = convoMap.get(contentTopic);
      if (convo instanceof ConversationV1) {
        return convo.decodeMessage(env);
      }
      if (convo instanceof ConversationV2) {
        return convo.decodeMessage(env);
      }
      console.log("Unknown topic");
      throw new Error("Unknown topic");
    };
    const addConvo = (topic, conversation) => {
      if (topics.has(topic)) {
        return false;
      }
      convoMap.set(topic, conversation);
      topics.add(topic);
      return true;
    };
    const contentTopicUpdater = (msg) => {
      if (msg instanceof DecodedMessage && msg.contentTopic === introTopic) {
        const convo = new ConversationV1(
          this.client,
          msg.recipientAddress === this.client.address ? msg.senderAddress : msg.recipientAddress,
          msg.sent
        );
        const isNew = addConvo(convo.topic, convo);
        return isNew ? Array.from(topics.values()) : void 0;
      }
      if (msg instanceof ConversationV2) {
        const isNew = addConvo(msg.topic, msg);
        return isNew ? Array.from(topics.values()) : void 0;
      }
      return void 0;
    };
    const str = await Stream.create(
      this.client,
      Array.from(topics.values()),
      decodeMessage,
      contentTopicUpdater
    );
    return async function* generate() {
      for await (const val of str) {
        if (val instanceof DecodedMessage) {
          yield val;
        }
        if (val instanceof ConversationV2) {
          for (const convoMessage of await val.messages()) {
            yield convoMessage;
          }
        }
      }
    }();
  }
  async getIntroductionPeers(opts) {
    const topic = buildUserIntroTopic(this.client.address);
    const messages = await this.client.listEnvelopes(
      topic,
      (env) => {
        return MessageV1.fromBytes(b64Decode(env.message));
      },
      opts
    );
    const seenPeers = /* @__PURE__ */ new Map();
    for (const message2 of messages) {
      if (!messageHasHeaders(message2)) {
        continue;
      }
      const peerAddress = this.getPeerAddress(message2);
      if (peerAddress) {
        const have = seenPeers.get(peerAddress);
        if (!have || have > message2.sent) {
          try {
            await message2.decrypt(
              this.client.keystore,
              this.client.publicKeyBundle
            );
            seenPeers.set(peerAddress, message2.sent);
          } catch (e) {
            continue;
          }
        }
      }
    }
    return seenPeers;
  }
  /**
   * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
   */
  async newConversation(peerAddress, context) {
    let contact2 = await this.client.getUserContact(peerAddress);
    if (!contact2) {
      throw new Error(`Recipient ${peerAddress} is not on the XMTP network`);
    }
    if (peerAddress === this.client.address) {
      throw new Error("self messaging not supported");
    }
    if (contact2 instanceof PublicKeyBundle && !context?.conversationId) {
      return new ConversationV1(this.client, peerAddress, /* @__PURE__ */ new Date());
    }
    if (!context?.conversationId) {
      const v1Convos = await this.listV1Conversations();
      const matchingConvo = v1Convos.find(
        (convo) => convo.peerAddress === peerAddress
      );
      if (matchingConvo) {
        if (!this.client.signedPublicKeyBundle.isFromLegacyBundle()) {
          throw new Error(
            "cannot resume pre-existing V1 conversation; client keys not compatible"
          );
        }
        if (!(contact2 instanceof PublicKeyBundle) && !contact2.isFromLegacyBundle()) {
          throw new Error(
            "cannot resume pre-existing V1 conversation; peer keys not compatible"
          );
        }
        return matchingConvo;
      }
    }
    if (contact2 instanceof PublicKeyBundle) {
      contact2 = SignedPublicKeyBundle.fromLegacyBundle(contact2);
    }
    const matcherFn = (convo) => convo.peerAddress === peerAddress && isMatchingContext(context, convo.context ?? void 0);
    return this.v2Mutex.runExclusive(async () => {
      const existing = await this.getV2ConversationsFromKeystore();
      const existingMatch = existing.find(matcherFn);
      if (existingMatch) {
        return existingMatch;
      }
      const latestSeen = existing[existing.length - 1]?.createdAt;
      const newItems = await this.updateV2Conversations(latestSeen);
      const newItemMatch = newItems.find(matcherFn);
      if (newItemMatch) {
        return newItemMatch;
      }
      return this.createV2Convo(contact2, context);
    });
  }
  async createV2Convo(recipient, context) {
    const timestamp = /* @__PURE__ */ new Date();
    const { payload, conversation } = await this.client.keystore.createInvite({
      recipient,
      context,
      createdNs: dateToNs(timestamp)
    });
    if (!payload || !conversation) {
      throw new Error("Required field not returned from Keystore");
    }
    const peerAddress = await recipient.walletSignatureAddress();
    await this.client.publishEnvelopes([
      {
        contentTopic: buildUserInviteTopic(peerAddress),
        message: payload,
        timestamp
      },
      {
        contentTopic: buildUserInviteTopic(this.client.address),
        message: payload,
        timestamp
      }
    ]);
    return this.conversationReferenceToV2(conversation);
  }
  getPeerAddress(message2) {
    const peerAddress = message2.recipientAddress === this.client.address ? message2.senderAddress : message2.recipientAddress;
    return peerAddress;
  }
};
function isMatchingContext(contextA, contextB) {
  return contextA?.conversationId === contextB?.conversationId;
}
function decodeContactBundle(bytes) {
  let cb;
  try {
    cb = contact.ContactBundle.decode(bytes);
  } catch (e) {
    const pb = publicKey.PublicKeyBundle.decode(bytes);
    cb = { v1: { keyBundle: new PublicKeyBundle(pb) }, v2: void 0 };
  }
  if (cb.v1?.keyBundle) {
    return new PublicKeyBundle(cb.v1.keyBundle);
  }
  if (cb.v2?.keyBundle) {
    return new SignedPublicKeyBundle(cb.v2.keyBundle);
  }
  throw new Error("unknown or invalid contact bundle");
}
function encodeContactBundle(bundle) {
  if (bundle instanceof PublicKeyBundle) {
    return contact.ContactBundle.encode({
      v1: { keyBundle: bundle },
      v2: void 0
    }).finish();
  } else {
    return contact.ContactBundle.encode({
      v1: void 0,
      v2: { keyBundle: bundle }
    }).finish();
  }
}

// src/authn/LocalAuthenticator.ts
var import_js_sha3 = __toESM(require_sha3(), 1);
var AuthData = class {
  constructor({ walletAddr, createdNs }) {
    this.walletAddr = walletAddr;
    this.createdNs = createdNs;
  }
  static create(walletAddr, timestamp) {
    timestamp = timestamp || /* @__PURE__ */ new Date();
    return new AuthData({
      walletAddr,
      createdNs: dateToNs(timestamp)
    });
  }
  static fromBytes(bytes) {
    const res = authn.AuthData.decode(bytes);
    return new AuthData(res);
  }
  toBytes() {
    return authn.AuthData.encode(this).finish();
  }
};
var Token = class {
  constructor({ identityKey, authDataBytes, authDataSignature }) {
    if (!identityKey) {
      throw new Error("Missing identity key in token");
    }
    if (!authDataSignature) {
      throw new Error("Missing authDataSignature in token");
    }
    this.identityKey = identityKey;
    this.authDataBytes = authDataBytes;
    this.authDataSignature = authDataSignature;
  }
  // Get AuthData, generating from bytes and cacheing the first time it is accessed
  get authData() {
    if (!this._authData) {
      this._authData = AuthData.fromBytes(this.authDataBytes);
    }
    return this._authData;
  }
  get ageMs() {
    const now = (/* @__PURE__ */ new Date()).valueOf();
    const authData = this.authData;
    const createdAt = authData.createdNs.div(1e6).toNumber();
    return now - createdAt;
  }
  toBytes() {
    return authn.Token.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new Token(authn.Token.decode(bytes));
  }
  toBase64() {
    return Buffer.from(this.toBytes()).toString("base64");
  }
};

// src/authn/LocalAuthenticator.ts
var LocalAuthenticator = class {
  constructor(identityKey) {
    if (!identityKey.publicKey.signature) {
      throw new Error("Provided public key is not signed");
    }
    this.identityKey = identityKey;
  }
  async createToken(timestamp) {
    const authData = AuthData.create(
      this.identityKey.publicKey.walletSignatureAddress(),
      timestamp || /* @__PURE__ */ new Date()
    );
    const authDataBytes = authData.toBytes();
    const digest = (0, import_js_sha3.keccak256)(authDataBytes);
    const authSig = await this.identityKey.sign(hexToBytes(digest));
    return new Token(
      authn.Token.fromPartial({
        identityKey: publicKey.PublicKey.fromPartial(
          // The generated types are overly strict and don't like our additional methods
          // eslint-disable-next-line
          // @ts-ignore
          this.identityKey.publicKey
        ),
        authDataBytes,
        // The generated types are overly strict and don't like our additional methods
        // eslint-disable-next-line
        // @ts-ignore
        authDataSignature: signature.Signature.fromPartial(authSig)
      })
    );
  }
};

// src/authn/KeystoreAuthenticator.ts
var wrapToken = (token) => {
  if (token instanceof Token) {
    return token;
  }
  return new Token(token);
};
var KeystoreAuthenticator = class {
  constructor(keystore6) {
    this.keystore = keystore6;
  }
  async createToken(timestamp) {
    const token = await this.keystore.createAuthToken({
      timestampNs: timestamp ? dateToNs(timestamp) : void 0
    });
    return wrapToken(token);
  }
};

// src/message-backup/NoBackupClient.ts
var BACKUP_TYPE = 0 /* none */;
var NoBackupClient = class {
  static createConfiguration() {
    return {
      type: BACKUP_TYPE,
      version: 0
    };
  }
  constructor(configuration) {
    this.configuration = configuration;
  }
  get backupType() {
    return BACKUP_TYPE;
  }
};

// src/message-backup/TopicStoreBackupClient.ts
var BACKUP_TYPE2 = 1 /* xmtpTopicStore */;
var TopicStoreBackupClient = class {
  static createConfiguration(walletAddress) {
    return {
      type: BACKUP_TYPE2,
      version: 0,
      topic: "history-v0:" + walletAddress
    };
  }
  constructor(configuration) {
    this.configuration = configuration;
  }
  get backupType() {
    return BACKUP_TYPE2;
  }
};

// src/message-backup/BackupClientFactory.ts
async function createBackupClient(walletAddress, selectBackupProvider) {
  const configuration = await fetchOrCreateConfiguration(
    walletAddress,
    selectBackupProvider
  );
  switch (configuration.type) {
    case 0 /* none */:
      return new NoBackupClient(configuration);
    case 1 /* xmtpTopicStore */:
      return new TopicStoreBackupClient(configuration);
  }
}
async function fetchOrCreateConfiguration(walletAddress, selectBackupProvider) {
  let backupConfiguration;
  const provider = await selectBackupProvider();
  switch (provider.type) {
    case 0 /* none */:
      backupConfiguration = NoBackupClient.createConfiguration();
      break;
    case 1 /* xmtpTopicStore */:
      backupConfiguration = TopicStoreBackupClient.createConfiguration(walletAddress);
      break;
  }
  return backupConfiguration;
}

// src/keystore/providers/errors.ts
var KeystoreProviderUnavailableError = class extends Error {
};
var { b64Decode: b64Decode2 } = fetcher;
var InvitationV1 = class {
  // eslint-disable-line camelcase
  constructor({
    topic,
    context,
    aes256GcmHkdfSha256
  }) {
    if (!topic || !topic.length) {
      throw new Error("Missing topic");
    }
    if (!aes256GcmHkdfSha256 || !aes256GcmHkdfSha256.keyMaterial || !aes256GcmHkdfSha256.keyMaterial.length) {
      throw new Error("Missing key material");
    }
    this.topic = topic;
    this.context = context;
    this.aes256GcmHkdfSha256 = aes256GcmHkdfSha256;
  }
  static createRandom(context) {
    const topic = buildDirectMessageTopicV2(
      Buffer.from(crypto_default.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g, "").replace("/", "-")
    );
    const keyMaterial = crypto_default.getRandomValues(new Uint8Array(32));
    return new InvitationV1({
      topic,
      aes256GcmHkdfSha256: { keyMaterial },
      context
    });
  }
  toBytes() {
    return invitation.InvitationV1.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new InvitationV1(invitation.InvitationV1.decode(bytes));
  }
};
var SealedInvitationHeaderV1 = class {
  constructor({
    sender,
    recipient,
    createdNs
  }) {
    if (!sender) {
      throw new Error("Missing sender");
    }
    if (!recipient) {
      throw new Error("Missing recipient");
    }
    this.sender = new SignedPublicKeyBundle(sender);
    this.recipient = new SignedPublicKeyBundle(recipient);
    this.createdNs = createdNs;
  }
  toBytes() {
    return invitation.SealedInvitationHeaderV1.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new SealedInvitationHeaderV1(
      invitation.SealedInvitationHeaderV1.decode(bytes)
    );
  }
};
var SealedInvitationV1 = class {
  constructor({ headerBytes, ciphertext: ciphertext4 }) {
    if (!headerBytes || !headerBytes.length) {
      throw new Error("Missing header bytes");
    }
    if (!ciphertext4) {
      throw new Error("Missing ciphertext");
    }
    this.headerBytes = headerBytes;
    this.ciphertext = new Ciphertext(ciphertext4);
  }
  /**
   * Accessor method for the full header object
   */
  get header() {
    if (this._header) {
      return this._header;
    }
    this._header = SealedInvitationHeaderV1.fromBytes(this.headerBytes);
    return this._header;
  }
  /**
   * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
   */
  async getInvitation(viewer) {
    if (this._invitation) {
      return this._invitation;
    }
    const header = this.header;
    let secret;
    if (viewer.identityKey.matches(this.header.sender.identityKey)) {
      secret = await viewer.sharedSecret(
        header.recipient,
        header.sender.preKey,
        false
      );
    } else {
      secret = await viewer.sharedSecret(
        header.sender,
        header.recipient.preKey,
        true
      );
    }
    const decryptedBytes = await decrypt(
      this.ciphertext,
      secret,
      this.headerBytes
    );
    this._invitation = InvitationV1.fromBytes(decryptedBytes);
    return this._invitation;
  }
  toBytes() {
    return invitation.SealedInvitationV1.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new SealedInvitationV1(invitation.SealedInvitationV1.decode(bytes));
  }
};
var SealedInvitation = class {
  constructor({ v1 }) {
    if (v1) {
      this.v1 = new SealedInvitationV1(v1);
    } else {
      throw new Error("Missing v1 or v2 invitation");
    }
  }
  toBytes() {
    return invitation.SealedInvitation.encode(this).finish();
  }
  static fromBytes(bytes) {
    return new SealedInvitation(invitation.SealedInvitation.decode(bytes));
  }
  static async fromEnvelope(env) {
    if (!env.message || !env.timestampNs) {
      throw new Error("invalid invitation envelope");
    }
    const sealed = SealedInvitation.fromBytes(
      b64Decode2(env.message)
    );
    const envelopeTime = Long.fromString(env.timestampNs);
    const headerTime = sealed.v1?.header.createdNs;
    if (!headerTime || !headerTime.equals(envelopeTime)) {
      throw new Error("envelope and header timestamp mistmatch");
    }
    return sealed;
  }
  /**
   * Create a SealedInvitation with a SealedInvitationV1 payload
   * Will encrypt all contents and validate inputs
   */
  static async createV1({
    sender,
    recipient,
    created,
    invitation: invitation3
  }) {
    const headerBytes = new SealedInvitationHeaderV1({
      sender: sender.getPublicKeyBundle(),
      recipient,
      createdNs: dateToNs(created)
    }).toBytes();
    const secret = await sender.sharedSecret(
      recipient,
      sender.getCurrentPreKey().publicKey,
      false
    );
    const invitationBytes = invitation3.toBytes();
    const ciphertext4 = await encrypt(invitationBytes, secret, headerBytes);
    return new SealedInvitation({
      v1: { headerBytes, ciphertext: ciphertext4 }
    });
  }
};

// src/keystore/encryption.ts
var decryptV1 = async (myKeys, peerKeys, ciphertext4, headerBytes, isSender) => {
  const secret = await myKeys.sharedSecret(
    peerKeys,
    myKeys.getCurrentPreKey().publicKey,
    // assumes that the current preKey is what was used to encrypt
    !isSender
  );
  return decrypt(ciphertext4, secret, headerBytes);
};
var encryptV1 = async (keys, recipient, message2, headerBytes) => {
  const secret = await keys.sharedSecret(
    recipient,
    keys.getCurrentPreKey().publicKey,
    false
    // assumes that the sender is the party doing the encrypting
  );
  return encrypt(message2, secret, headerBytes);
};
var decryptV2 = (ciphertext4, secret, headerBytes) => decrypt(ciphertext4, secret, headerBytes);
var encryptV2 = (payload, secret, headerBytes) => encrypt(payload, secret, headerBytes);
var convertError = (e, errorCode) => {
  if (e instanceof KeystoreError) {
    return e;
  }
  return new KeystoreError(errorCode, e.message);
};
var wrapResult = (result) => ({ result });
var mapAndConvertErrors = (input, mapper, errorCode) => {
  return Promise.all(
    input.map(async (item) => {
      try {
        return wrapResult(await mapper(item));
      } catch (e) {
        return { error: convertError(e, errorCode) };
      }
    })
  );
};
var toPublicKeyBundle = (bundle) => {
  if (bundle instanceof PublicKeyBundle) {
    return bundle;
  }
  return new PublicKeyBundle(bundle);
};
var toSignedPublicKeyBundle = (bundle) => {
  if (bundle instanceof SignedPublicKeyBundle) {
    return bundle;
  }
  return new SignedPublicKeyBundle(bundle);
};
var validateObject = (obj, objectFields, arrayFields) => {
  for (const field of objectFields) {
    if (!obj[field]) {
      throw new KeystoreError(
        keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,
        `Missing field ${String(field)}`
      );
    }
  }
  for (const field of arrayFields) {
    const val = obj[field];
    if (!val || !val?.length) {
      throw new KeystoreError(
        keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,
        `Missing field ${String(field)}`
      );
    }
  }
  return true;
};
var getKeyMaterial = (invite) => {
  if (!invite?.aes256GcmHkdfSha256?.keyMaterial) {
    throw new KeystoreError(
      keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,
      "Missing key material"
    );
  }
  return invite.aes256GcmHkdfSha256.keyMaterial;
};
var topicDataToConversationReference = ({
  invitation: invitation3,
  createdNs,
  peerAddress
}) => ({
  context: invitation3.context,
  topic: invitation3.topic,
  peerAddress,
  createdNs
});
var isCompleteTopicData = (obj) => !!obj.invitation;
var typeSafeTopicMap = (topicMap) => {
  const out = {};
  for (const [topic, topicData] of Object.entries(topicMap.topics)) {
    if (isCompleteTopicData(topicData)) {
      out[topic] = topicData;
    } else {
      console.warn("Invitation missing from topic data");
    }
  }
  return out;
};
var INVITE_KEY = "invitations/v1";
var InviteStore = class {
  constructor(persistence, initialData = /* @__PURE__ */ new Map()) {
    this.persistence = persistence;
    this.mutex = new Mutex();
    this.topicMap = initialData;
  }
  static async create(persistence) {
    if (persistence) {
      const rawData = await persistence.getItem(INVITE_KEY);
      if (rawData) {
        try {
          const inviteMap = typeSafeTopicMap(keystore.TopicMap.decode(rawData));
          return new InviteStore(
            persistence,
            new Map(Object.entries(inviteMap))
          );
        } catch (e) {
          console.warn(`Error loading invites from store: ${e}`);
        }
      }
    }
    return new InviteStore(persistence);
  }
  async add(topicData) {
    await this.mutex.runExclusive(async () => {
      let isDirty = false;
      for (const row of topicData) {
        if (!this.topicMap.has(row.invitation.topic)) {
          this.topicMap.set(row.invitation.topic, row);
          isDirty = true;
        }
      }
      if (isDirty && this.persistence) {
        await this.persistence.setItem(INVITE_KEY, this.toBytes());
      }
    });
  }
  get topics() {
    return [...this.topicMap.values()];
  }
  lookup(topic) {
    return this.topicMap.get(topic);
  }
  toBytes() {
    return keystore.TopicMap.encode({
      topics: Object.fromEntries(this.topicMap)
    }).finish();
  }
};
var EC = elliptic.ec;
var ec = new EC("secp256k1");
var subtle = crypto_default.subtle;
var EC_GROUP_ORDER = Buffer.from(
  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  "hex"
);
var ZERO32 = Buffer.alloc(32, 0);
function assert(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "Assertion failed");
  }
}
function isScalar(x) {
  return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey(privateKey3) {
  if (!isScalar(privateKey3)) {
    return false;
  }
  return privateKey3.compare(ZERO32) > 0 && // > 0
  privateKey3.compare(EC_GROUP_ORDER) < 0;
}
function equalConstTime(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  let res = 0;
  for (let i = 0; i < b1.length; i++) {
    res |= b1[i] ^ b2[i];
  }
  return res === 0;
}
function randomBytes(size) {
  const arr = new Uint8Array(size);
  crypto_default.getRandomValues(arr);
  return Buffer.from(arr);
}
async function sha512(msg) {
  const digest = await subtle.digest("SHA-512", msg);
  return Buffer.from(digest);
}
function getAes(op) {
  return function(iv, key, data) {
    return new Promise(function(resolve) {
      const importAlgorithm = { name: "AES-CBC" };
      const keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
      return keyp.then(function(cryptoKey) {
        const encAlgorithm = { name: "AES-CBC", iv };
        return subtle[op](encAlgorithm, cryptoKey, data);
      }).then(function(result) {
        resolve(Buffer.from(new Uint8Array(result)));
      });
    });
  };
}
var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");
async function hmacSha256Sign(key, msg) {
  const newKey = await subtle.importKey(
    "raw",
    key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return Buffer.from(
    await subtle.sign({ name: "HMAC", hash: "SHA-256" }, newKey, msg)
  );
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await hmacSha256Sign(key, msg);
  return equalConstTime(expectedSig, sig);
}
function getPublic(privateKey3) {
  assert(privateKey3.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey3), "Bad private key");
  return Buffer.from(ec.keyFromPrivate(privateKey3).getPublic("array"));
}
function derive(privateKeyA, publicKeyB) {
  return new Promise(function(resolve) {
    assert(Buffer.isBuffer(privateKeyA), "Bad private key");
    assert(Buffer.isBuffer(publicKeyB), "Bad public key");
    assert(privateKeyA.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKeyA), "Bad private key");
    assert(
      publicKeyB.length === 65 || publicKeyB.length === 33,
      "Bad public key"
    );
    if (publicKeyB.length === 65) {
      assert(publicKeyB[0] === 4, "Bad public key");
    }
    if (publicKeyB.length === 33) {
      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
    }
    const keyA = ec.keyFromPrivate(privateKeyA);
    const keyB = ec.keyFromPublic(publicKeyB);
    const Px = keyA.derive(keyB.getPublic());
    resolve(Buffer.from(Px.toArray()));
  });
}
async function encrypt2(publicKeyTo, msg, opts) {
  opts = opts || {};
  const iv = opts?.iv || randomBytes(16);
  let ephemPrivateKey = opts?.ephemPrivateKey || randomBytes(32);
  while (!isValidPrivateKey(ephemPrivateKey)) {
    if (opts?.ephemPrivateKey) {
      throw new Error("ephemPrivateKey is not valid");
    }
    ephemPrivateKey = randomBytes(32);
  }
  const ephemeralPublicKey = getPublic(ephemPrivateKey);
  const hash = await sha512(await derive(ephemPrivateKey, publicKeyTo));
  const encryptionKey = hash.slice(0, 32);
  const macKey = hash.slice(32);
  const ciphertext4 = await aesCbcEncrypt(iv, encryptionKey, msg);
  const dataToMac = Buffer.concat([iv, ephemeralPublicKey, ciphertext4]);
  const mac = await hmacSha256Sign(macKey, dataToMac);
  return {
    iv,
    ephemeralPublicKey,
    ciphertext: ciphertext4,
    mac
  };
}
async function decrypt2(privateKey3, opts) {
  const px = await derive(privateKey3, opts.ephemeralPublicKey);
  const hash = await sha512(px);
  const encryptionKey = hash.slice(0, 32);
  const macKey = hash.slice(32);
  const dataToMac = Buffer.concat([
    opts.iv,
    opts.ephemeralPublicKey,
    opts.ciphertext
  ]);
  assert(await hmacSha256Verify(macKey, dataToMac, opts.mac), "Bad mac");
  return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
}

// src/keystore/InMemoryKeystore.ts
var { ErrorCode } = keystore;
var INVITE_SALT = new TextEncoder().encode("__XMTP__INVITATION__SALT__XMTP__");
async function deriveKey(secret, info) {
  const key = await crypto_default.subtle.importKey("raw", secret, "HKDF", false, [
    "deriveKey"
  ]);
  return crypto_default.subtle.deriveKey(
    { name: "HKDF", hash: "SHA-256", salt: INVITE_SALT, info },
    key,
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"]
  );
}
var InMemoryKeystore = class {
  constructor(keys, inviteStore) {
    this.v1Keys = keys;
    this.v2Keys = PrivateKeyBundleV2.fromLegacyBundle(keys);
    this.inviteStore = inviteStore;
    this.authenticator = new LocalAuthenticator(keys.identityKey);
  }
  static async create(keys, persistence) {
    return new InMemoryKeystore(keys, await InviteStore.create(persistence));
  }
  async decryptV1(req) {
    const responses = await mapAndConvertErrors(
      req.requests,
      async (req2) => {
        if (!validateObject(req2, ["payload", "peerKeys"], ["headerBytes"])) ;
        const { payload, peerKeys, headerBytes, isSender } = req2;
        const decrypted = await decryptV1(
          this.v1Keys,
          toPublicKeyBundle(peerKeys),
          payload,
          headerBytes,
          isSender
        );
        return {
          decrypted
        };
      },
      keystore.ErrorCode.ERROR_CODE_UNSPECIFIED
    );
    return keystore.DecryptResponse.fromPartial({
      responses
    });
  }
  async decryptV2(req) {
    const responses = await mapAndConvertErrors(
      req.requests,
      async (req2) => {
        if (!validateObject(req2, ["payload"], ["headerBytes"])) ;
        const { payload, headerBytes, contentTopic } = req2;
        const topicData = this.inviteStore.lookup(contentTopic);
        if (!topicData) {
          throw new KeystoreError(
            keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,
            "no topic key"
          );
        }
        const decrypted = await decryptV2(
          payload,
          getKeyMaterial(topicData.invitation),
          headerBytes
        );
        return { decrypted };
      },
      ErrorCode.ERROR_CODE_UNSPECIFIED
    );
    return keystore.DecryptResponse.fromPartial({
      responses
    });
  }
  async encryptV1(req) {
    const responses = await mapAndConvertErrors(
      req.requests,
      async (req2) => {
        if (!validateObject(req2, ["payload", "recipient"], ["headerBytes"])) ;
        const { recipient, payload, headerBytes } = req2;
        return {
          encrypted: await encryptV1(
            this.v1Keys,
            toPublicKeyBundle(recipient),
            payload,
            headerBytes
          )
        };
      },
      ErrorCode.ERROR_CODE_UNSPECIFIED
    );
    return keystore.EncryptResponse.fromPartial({
      responses
    });
  }
  async createAuthToken({
    timestampNs
  }) {
    return this.authenticator.createToken(
      timestampNs ? nsToDate(timestampNs) : void 0
    );
  }
  async encryptV2(req) {
    const responses = await mapAndConvertErrors(
      req.requests,
      async (req2) => {
        if (!validateObject(req2, ["payload"], ["headerBytes"])) ;
        const { payload, headerBytes, contentTopic } = req2;
        const topicData = this.inviteStore.lookup(contentTopic);
        if (!topicData) {
          throw new KeystoreError(
            ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,
            "no topic key"
          );
        }
        return {
          encrypted: await encryptV2(
            payload,
            getKeyMaterial(topicData.invitation),
            headerBytes
          )
        };
      },
      ErrorCode.ERROR_CODE_INVALID_INPUT
    );
    return keystore.EncryptResponse.fromPartial({
      responses
    });
  }
  async saveInvites(req) {
    const toAdd = [];
    const responses = await mapAndConvertErrors(
      req.requests,
      async ({ payload, timestampNs }) => {
        const sealed = SealedInvitation.fromBytes(payload);
        if (sealed.v1) {
          const headerTime = sealed.v1.header.createdNs;
          if (!headerTime.equals(timestampNs)) {
            throw new Error("envelope and header timestamp mismatch");
          }
          const isSender = sealed.v1.header.sender.equals(
            this.v2Keys.getPublicKeyBundle()
          );
          const invitation3 = await sealed.v1.getInvitation(this.v2Keys);
          const topicData = {
            invitation: invitation3,
            createdNs: sealed.v1.header.createdNs,
            peerAddress: isSender ? await sealed.v1.header.recipient.walletSignatureAddress() : await sealed.v1.header.sender.walletSignatureAddress()
          };
          toAdd.push(topicData);
          return {
            conversation: topicDataToConversationReference(topicData)
          };
        }
      },
      ErrorCode.ERROR_CODE_INVALID_INPUT
    );
    await this.inviteStore.add(toAdd);
    return keystore.SaveInvitesResponse.fromPartial({
      responses
    });
  }
  async createInvite(req) {
    try {
      if (!validateObject(req, ["recipient"], [])) ;
      const created = nsToDate(req.createdNs);
      const recipient = toSignedPublicKeyBundle(req.recipient);
      const secret = await this.v2Keys.sharedSecret(
        recipient,
        this.v2Keys.getCurrentPreKey().publicKey,
        false
      );
      const sortedAddresses = [
        this.accountAddress,
        await recipient.walletSignatureAddress()
      ].sort();
      const msgString = (req.context?.conversationId || "") + sortedAddresses.join();
      const msgBytes = new TextEncoder().encode(msgString);
      const topic = bytesToHex(
        await hmacSha256Sign(Buffer.from(secret), Buffer.from(msgBytes))
      );
      const infoString = [
        "0",
        // sequence number
        ...sortedAddresses
      ].join("|");
      const info = new TextEncoder().encode(infoString);
      const derivedKey = await deriveKey(secret, info);
      const keyMaterial = new Uint8Array(
        await crypto_default.subtle.exportKey("raw", derivedKey)
      );
      const invitation3 = new InvitationV1({
        topic: buildDirectMessageTopicV2(topic),
        aes256GcmHkdfSha256: { keyMaterial },
        context: req.context
      });
      const sealed = await SealedInvitation.createV1({
        sender: this.v2Keys,
        recipient,
        created,
        invitation: invitation3
      });
      const topicData = {
        invitation: invitation3,
        createdNs: req.createdNs,
        peerAddress: await recipient.walletSignatureAddress()
      };
      await this.inviteStore.add([topicData]);
      return keystore.CreateInviteResponse.fromPartial({
        conversation: topicDataToConversationReference(topicData),
        payload: sealed.toBytes()
      });
    } catch (e) {
      throw convertError(e, ErrorCode.ERROR_CODE_INVALID_INPUT);
    }
  }
  async signDigest(req) {
    if (!validateObject(req, ["digest"], [])) ;
    const { digest, identityKey, prekeyIndex } = req;
    let key;
    if (identityKey) {
      key = this.v1Keys.identityKey;
    } else if (typeof prekeyIndex !== "undefined" && Number.isInteger(prekeyIndex)) {
      key = this.v1Keys.preKeys[prekeyIndex];
      if (!key) {
        throw new KeystoreError(
          ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,
          "no prekey found"
        );
      }
    } else {
      throw new KeystoreError(
        ErrorCode.ERROR_CODE_INVALID_INPUT,
        "must specifify identityKey or prekeyIndex"
      );
    }
    return key.sign(digest);
  }
  async getV2Conversations() {
    const convos = this.inviteStore.topics.map(
      (invite) => topicDataToConversationReference(invite)
    );
    convos.sort(
      (a, b) => a.createdNs.div(1e6).sub(b.createdNs.div(1e6)).toNumber()
    );
    return convos;
  }
  async getPublicKeyBundle() {
    return this.v1Keys.getPublicKeyBundle();
  }
  async getPrivateKeyBundle() {
    return this.v1Keys;
  }
  async getAccountAddress() {
    if (!this.accountAddress) {
      this.accountAddress = await this.v2Keys.getPublicKeyBundle().walletSignatureAddress();
    }
    return this.accountAddress;
  }
  // This method is not defined as part of the standard Keystore API, but is available
  // on the InMemoryKeystore to support legacy use-cases.
  lookupTopic(topic) {
    return this.inviteStore.lookup(topic);
  }
};
var TopicPersistence = class {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  // Returns the first record in a topic if it is present.
  async getItem(key) {
    for await (const env of this.apiClient.queryIterator(
      { contentTopic: this.buildTopic(key) },
      {
        pageSize: 1,
        direction: messageApi.SortDirection.SORT_DIRECTION_DESCENDING
      }
    )) {
      if (!env.message)
        continue;
      try {
        const bytes = b64Decode(env.message.toString());
        return Uint8Array.from(bytes);
      } catch (e) {
        console.log(e);
      }
    }
    return null;
  }
  async setItem(key, value) {
    const keys = Uint8Array.from(value);
    await this.apiClient.publish([
      {
        contentTopic: this.buildTopic(key),
        message: keys
      }
    ]);
  }
  setAuthenticator(authenticator) {
    this.apiClient.setAuthenticator(authenticator);
  }
  buildTopic(key) {
    return buildUserPrivateStoreTopic(key);
  }
};

// src/keystore/persistence/LocalStoragePonyfill.ts
var LocalStoragePonyfill = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  get length() {
    return this.store.size;
  }
  clear() {
    this.store = /* @__PURE__ */ new Map();
  }
  getItem(key) {
    this.validateString(key);
    if (this.store.has(key)) {
      return String(this.store.get(key));
    }
    return null;
  }
  key(index) {
    if (index === void 0) {
      throw new TypeError(
        "Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present."
      );
    }
    const keys = [...this.store.keys()];
    if (index >= keys.length) {
      return null;
    }
    return keys[index];
  }
  removeItem(key) {
    this.validateString(key);
    this.store.delete(key);
  }
  setItem(key, value) {
    this.validateString(key);
    this.validateString(value);
    this.store.set(String(key), String(value));
  }
  validateString(val) {
    if (!(typeof val === "string")) {
      throw new TypeError("Key must be a string");
    }
  }
};

// src/keystore/persistence/LocalStoragePersistence.ts
var LocalStoragePersistence = class {
  constructor() {
    this.storage = typeof localStorage !== "undefined" ? localStorage : new LocalStoragePonyfill();
  }
  async getItem(key) {
    const value = this.storage.getItem(key);
    if (value === null) {
      return null;
    }
    return Uint8Array.from(Buffer.from(value, "binary"));
  }
  async setItem(key, value) {
    this.storage.setItem(key, Buffer.from(value).toString("binary"));
  }
};

// src/keystore/persistence/PrefixedPersistence.ts
var PrefixedPersistence = class {
  constructor(prefix, persistence) {
    this.prefix = prefix;
    this.persistence = persistence;
  }
  getItem(key) {
    return this.persistence.getItem(this.buildKey(key));
  }
  setItem(key, value) {
    return this.persistence.setItem(this.buildKey(key), value);
  }
  buildKey(key) {
    return this.prefix + key;
  }
};

// src/keystore/persistence/EncryptedPersistence.ts
var EncryptedPersistence = class {
  constructor(persistence, privateKey3) {
    this.persistence = persistence;
    this.privateKey = privateKey3;
    this.privateKeyBytes = Buffer.from(privateKey3.secp256k1.bytes);
    this.publicKey = getPublic(this.privateKeyBytes);
  }
  async getItem(key) {
    const encrypted = await this.persistence.getItem(key);
    if (encrypted) {
      return this.decrypt(encrypted);
    }
    return null;
  }
  async setItem(key, value) {
    const encrypted = await this.encrypt(value);
    await this.persistence.setItem(key, encrypted);
  }
  async encrypt(value) {
    const ecies = await encrypt2(this.publicKey, Buffer.from(value));
    return this.serializeEcies(ecies);
  }
  async decrypt(value) {
    const ecies = await this.deserializeEcies(value);
    const result = await decrypt2(this.privateKeyBytes, ecies);
    return Uint8Array.from(result);
  }
  async serializeEcies(data) {
    const protoVal = await SignedEciesCiphertext.create(data, this.privateKey);
    return protoVal.toBytes();
  }
  async deserializeEcies(data) {
    const protoVal = SignedEciesCiphertext.fromBytes(data);
    if (!await protoVal.verify(this.privateKey.publicKey)) {
      throw new Error("signature validation failed");
    }
    const ecies = protoVal.ciphertext;
    return {
      ciphertext: Buffer.from(ecies.ciphertext),
      mac: Buffer.from(ecies.mac),
      iv: Buffer.from(ecies.iv),
      ephemeralPublicKey: Buffer.from(ecies.ephemeralPublicKey)
    };
  }
};

// src/keystore/providers/helpers.ts
var buildPersistenceFromOptions = async (opts, keys) => {
  if (!opts.persistConversations) {
    return void 0;
  }
  const address = await keys.identityKey.publicKey.walletSignatureAddress();
  const prefix = `xmtp/${opts.env}/${address}/`;
  return new PrefixedPersistence(
    prefix,
    new EncryptedPersistence(new LocalStoragePersistence(), keys.identityKey)
  );
};
var KEY_BUNDLE_NAME = "key_bundle";
var NetworkKeyManager = class {
  constructor(signer, persistence, preEnableIdentityCallback) {
    this.signer = signer;
    this.persistence = persistence;
    this.preEnableIdentityCallback = preEnableIdentityCallback;
  }
  async getStorageAddress(name) {
    let walletAddress = await this.signer.getAddress();
    walletAddress = utils.getAddress(walletAddress);
    return `${walletAddress}/${name}`;
  }
  // Retrieve a private key bundle for the active wallet address in the signer
  async loadPrivateKeyBundle() {
    const storageBuffer = await this.persistence.getItem(
      await this.getStorageAddress(KEY_BUNDLE_NAME)
    );
    if (!storageBuffer) {
      return null;
    }
    const [bundle, needsUpdate] = await this.fromEncryptedBytes(
      this.signer,
      Uint8Array.from(storageBuffer)
    );
    if (needsUpdate) {
      await this.storePrivateKeyBundle(bundle);
    }
    return bundle;
  }
  // Store the private key bundle at an address generated based on the active wallet in the signer
  async storePrivateKeyBundle(bundle) {
    const keyAddress = await this.getStorageAddress(KEY_BUNDLE_NAME);
    const encodedBundle = await this.toEncryptedBytes(bundle, this.signer);
    if (typeof this.persistence.setAuthenticator === "function") {
      this.persistence.setAuthenticator(
        new LocalAuthenticator(bundle.identityKey)
      );
    }
    await this.persistence.setItem(keyAddress, encodedBundle);
  }
  // encrypts/serializes the bundle for storage
  async toEncryptedBytes(bundle, wallet) {
    const bytes = bundle.encode();
    const wPreKey = crypto_default.getRandomValues(new Uint8Array(32));
    const input = storageSigRequestText(wPreKey);
    const walletAddr = await wallet.getAddress();
    if (this.preEnableIdentityCallback) {
      await this.preEnableIdentityCallback();
    }
    let sig = await wallet.signMessage(input);
    let address = utils.verifyMessage(input, sig);
    if (address !== walletAddr) {
      sig = await wallet.signMessage(input);
      console.log("invalid signature, retrying");
      address = utils.verifyMessage(input, sig);
      if (address !== walletAddr) {
        throw new Error("invalid signature");
      }
    }
    const secret = hexToBytes(sig);
    const ciphertext4 = await encrypt(bytes, secret);
    return privateKey.EncryptedPrivateKeyBundle.encode({
      v1: {
        walletPreKey: wPreKey,
        ciphertext: ciphertext4
      }
    }).finish();
  }
  // decrypts/deserializes the bundle from storage bytes
  async fromEncryptedBytes(wallet, bytes) {
    const [eBundle, needsUpdate] = getEncryptedBundle(bytes);
    if (!eBundle.walletPreKey) {
      throw new Error("missing wallet pre-key");
    }
    if (!eBundle.ciphertext?.aes256GcmHkdfSha256) {
      throw new Error("missing bundle ciphertext");
    }
    if (this.preEnableIdentityCallback) {
      await this.preEnableIdentityCallback();
    }
    const secret = hexToBytes(
      await wallet.signMessage(storageSigRequestText(eBundle.walletPreKey))
    );
    try {
      const ciphertext4 = new Ciphertext(eBundle.ciphertext);
      const decrypted = await decrypt(ciphertext4, secret);
      const [bundle, needsUpdate2] = getPrivateBundle(decrypted);
      return [bundle, needsUpdate || needsUpdate2];
    } catch (e) {
      if (secret.length !== 65) {
        throw new Error(
          "Expected 65 bytes before trying a different recovery byte"
        );
      }
      const lastByte = secret[secret.length - 1];
      let newSecret = secret.slice(0, secret.length - 1);
      if (lastByte < 27) {
        newSecret = new Uint8Array([...newSecret, lastByte + 27]);
      } else {
        newSecret = new Uint8Array([...newSecret, lastByte - 27]);
      }
      const ciphertext4 = new Ciphertext(eBundle.ciphertext);
      const decrypted = await decrypt(ciphertext4, newSecret);
      const [bundle, needsUpdate2] = getPrivateBundle(decrypted);
      return [bundle, needsUpdate || needsUpdate2];
    }
  }
};
function getEncryptedBundle(bytes) {
  try {
    const b = privateKey.EncryptedPrivateKeyBundle.decode(bytes);
    if (b.v1) {
      return [b.v1, false];
    }
  } catch (e) {
    return [privateKey.EncryptedPrivateKeyBundleV1.decode(bytes), true];
  }
  throw new Error("unrecognized encrypted private key bundle version");
}
function getPrivateBundle(bytes) {
  try {
    const b = decodePrivateKeyBundle(bytes);
    if (b instanceof PrivateKeyBundleV2) {
      throw new Error("V2 bundles not supported yet");
    }
    return [b, false];
  } catch (e) {
    const b = privateKey.PrivateKeyBundleV1.decode(bytes);
    return [new PrivateKeyBundleV1(b), true];
  }
}
function storageSigRequestText(preKey) {
  return `XMTP : Enable Identity
${bytesToHex(preKey)}

For more info: https://xmtp.org/signatures/`;
}

// src/keystore/providers/KeyGeneratorKeystoreProvider.ts
var KeyGeneratorKeystoreProvider = class {
  async newKeystore(opts, apiClient, wallet) {
    if (!wallet) {
      throw new KeystoreProviderUnavailableError(
        "Wallet required to generate new keys"
      );
    }
    if (opts.preCreateIdentityCallback) {
      await opts.preCreateIdentityCallback();
    }
    const bundle = await PrivateKeyBundleV1.generate(wallet);
    const manager = new NetworkKeyManager(
      wallet,
      new TopicPersistence(apiClient),
      opts.preEnableIdentityCallback
    );
    await manager.storePrivateKeyBundle(bundle);
    return InMemoryKeystore.create(
      bundle,
      await buildPersistenceFromOptions(opts, bundle)
    );
  }
};

// src/keystore/providers/NetworkKeystoreProvider.ts
var NetworkKeystoreProvider = class {
  async newKeystore(opts, apiClient, wallet) {
    if (!wallet) {
      throw new KeystoreProviderUnavailableError("No wallet provided");
    }
    const loader = new NetworkKeyManager(
      wallet,
      new TopicPersistence(apiClient),
      opts.preEnableIdentityCallback
    );
    const keys = await loader.loadPrivateKeyBundle();
    if (!keys) {
      throw new KeystoreProviderUnavailableError("No keys found");
    }
    return InMemoryKeystore.create(
      keys,
      await buildPersistenceFromOptions(opts, keys)
    );
  }
};

// src/keystore/providers/StaticKeystoreProvider.ts
var StaticKeystoreProvider = class {
  async newKeystore(opts) {
    const { privateKeyOverride } = opts;
    if (!privateKeyOverride) {
      throw new KeystoreProviderUnavailableError(
        "No private key override provided"
      );
    }
    const bundle = decodePrivateKeyBundle(privateKeyOverride);
    if (bundle instanceof PrivateKeyBundleV2) {
      throw new Error("V2 private key bundle found. Only V1 supported");
    }
    return InMemoryKeystore.create(
      bundle,
      await buildPersistenceFromOptions(opts, bundle)
    );
  }
};

// src/Client.ts
var { Compression } = content;
var { b64Decode: b64Decode3 } = fetcher;
var MaxContentSize = 100 * 1024 * 1024;
function defaultOptions(opts) {
  const _defaultOptions = {
    privateKeyOverride: void 0,
    env: "dev",
    apiUrl: void 0,
    codecs: [new TextCodec()],
    maxContentSize: MaxContentSize,
    persistConversations: true,
    skipContactPublishing: false,
    keystoreProviders: defaultKeystoreProviders()
  };
  if (opts?.codecs) {
    opts.codecs = _defaultOptions.codecs.concat(opts.codecs);
  }
  return { ..._defaultOptions, ...opts };
}
var Client = class {
  constructor(publicKeyBundle, apiClient, backupClient, keystore6) {
    this.contacts = /* @__PURE__ */ new Set();
    this.knownPublicKeyBundles = /* @__PURE__ */ new Map();
    this.keystore = keystore6;
    this.publicKeyBundle = publicKeyBundle;
    this.address = publicKeyBundle.walletSignatureAddress();
    this._conversations = new Conversations(this);
    this._codecs = /* @__PURE__ */ new Map();
    this._maxContentSize = MaxContentSize;
    this.apiClient = apiClient;
    this._backupClient = backupClient;
  }
  /**
   * @type {Conversations}
   */
  get conversations() {
    return this._conversations;
  }
  get backupType() {
    return this._backupClient.backupType;
  }
  get signedPublicKeyBundle() {
    return SignedPublicKeyBundle.fromLegacyBundle(this.publicKeyBundle);
  }
  /**
   * Create and start a client associated with given wallet.
   *
   * @param wallet the wallet as a Signer instance
   * @param opts specify how to to connect to the network
   */
  static async create(wallet, opts) {
    const options = defaultOptions(opts);
    const apiClient = createApiClientFromOptions(options);
    const keystore6 = await bootstrapKeystore(options, apiClient, wallet);
    const publicKeyBundle = new PublicKeyBundle(
      await keystore6.getPublicKeyBundle()
    );
    const address = publicKeyBundle.walletSignatureAddress();
    apiClient.setAuthenticator(new KeystoreAuthenticator(keystore6));
    const backupClient = await Client.setupBackupClient(address, options.env);
    const client = new Client(
      publicKeyBundle,
      apiClient,
      backupClient,
      keystore6
    );
    await client.init(options);
    return client;
  }
  /**
   * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.
   *
   * This bundle can then be provided as `privateKeyOverride` in a
   * subsequent call to `Client.create(...)`
   *
   * Be very careful with these keys, as they can be used to
   * impersonate a user on the XMTP network and read the user's
   * messages.
   */
  static async getKeys(wallet, opts) {
    const client = await Client.create(wallet, opts);
    const keys = await client.keystore.getPrivateKeyBundle();
    return new PrivateKeyBundleV1(keys).encode();
  }
  static async setupBackupClient(walletAddress, env) {
    const selectBackupProvider = async () => {
      return Promise.resolve({
        type: env === "local" ? 1 /* xmtpTopicStore */ : 0 /* none */
      });
    };
    return createBackupClient(walletAddress, selectBackupProvider);
  }
  async init(options) {
    options.codecs.forEach((codec) => {
      this.registerCodec(codec);
    });
    this._maxContentSize = options.maxContentSize;
    if (!options.skipContactPublishing) {
      await this.ensureUserContactPublished(options.publishLegacyContact);
    }
  }
  // gracefully shut down the client
  async close() {
    return void 0;
  }
  async ensureUserContactPublished(legacy = false) {
    const bundle = await getUserContactFromNetwork(this.apiClient, this.address);
    if (bundle && bundle instanceof SignedPublicKeyBundle && this.signedPublicKeyBundle.equals(bundle)) {
      return;
    }
    await this.publishUserContact(true);
    if (!legacy) {
      await this.publishUserContact(legacy);
    }
  }
  // PRIVATE: publish the key bundle into the contact topic
  // left public for testing purposes
  async publishUserContact(legacy = false) {
    const bundle = legacy ? this.publicKeyBundle : this.signedPublicKeyBundle;
    await this.publishEnvelopes([
      {
        contentTopic: buildUserContactTopic(this.address),
        message: encodeContactBundle(bundle)
      }
    ]);
  }
  /**
   * Returns the cached PublicKeyBundle if one is known for the given address or fetches
   * one from the network
   *
   * This throws if either the address is invalid or the contact is not published.
   * See also [#canMessage].
   */
  async getUserContact(peerAddress) {
    peerAddress = utils.getAddress(peerAddress);
    const existingBundle = this.knownPublicKeyBundles.get(peerAddress);
    if (existingBundle) {
      return existingBundle;
    }
    const newBundle = await getUserContactFromNetwork(
      this.apiClient,
      peerAddress
    );
    if (newBundle) {
      this.knownPublicKeyBundles.set(peerAddress, newBundle);
    }
    return newBundle;
  }
  /**
   * Identical to getUserContact but for multiple peer addresses
   */
  async getUserContacts(peerAddresses) {
    const normalizedAddresses = peerAddresses.map(
      (address) => utils.getAddress(address)
    );
    const addressToBundle = /* @__PURE__ */ new Map();
    const uncachedAddresses = [];
    for (const address of normalizedAddresses) {
      const existingBundle = this.knownPublicKeyBundles.get(address);
      if (existingBundle) {
        addressToBundle.set(address, existingBundle);
      } else {
        addressToBundle.set(address, void 0);
        uncachedAddresses.push(address);
      }
    }
    const newBundles = await getUserContactsFromNetwork(
      this.apiClient,
      uncachedAddresses
    );
    for (let i = 0; i < newBundles.length; i++) {
      const address = uncachedAddresses[i];
      const bundle = newBundles[i];
      addressToBundle.set(address, bundle);
      if (bundle) {
        this.knownPublicKeyBundles.set(address, bundle);
      }
    }
    return normalizedAddresses.map((address) => addressToBundle.get(address));
  }
  /**
   * Used to force getUserContact fetch contact from the network.
   */
  forgetContact(peerAddress) {
    peerAddress = utils.getAddress(peerAddress);
    this.knownPublicKeyBundles.delete(peerAddress);
  }
  /**
   * Check if @peerAddress can be messaged, specifically
   * it checks that a PublicKeyBundle can be found for the given address
   */
  async canMessage(peerAddress) {
    try {
      if (Array.isArray(peerAddress)) {
        const contacts = await this.getUserContacts(peerAddress);
        return contacts.map((contact2) => !!contact2);
      }
      const keyBundle = await this.getUserContact(peerAddress);
      return keyBundle !== void 0;
    } catch (e) {
      return false;
    }
  }
  static async canMessage(peerAddress, opts) {
    const apiUrl = opts?.apiUrl || ApiUrls[opts?.env || "dev"];
    if (Array.isArray(peerAddress)) {
      const rawPeerAddresses = peerAddress;
      const normalizedPeerAddresses = rawPeerAddresses.map(
        (address) => utils.getAddress(address)
      );
      const contacts = await getUserContactsFromNetwork(
        new ApiClient(apiUrl, { appVersion: opts?.appVersion }),
        normalizedPeerAddresses
      );
      return contacts.map((contact2) => !!contact2);
    }
    try {
      peerAddress = utils.getAddress(peerAddress);
    } catch (e) {
      return false;
    }
    const keyBundle = await getUserContactFromNetwork(
      new ApiClient(apiUrl, { appVersion: opts?.appVersion }),
      peerAddress
    );
    return keyBundle !== void 0;
  }
  validateEnvelope(env) {
    const bytes = env.message;
    if (!env.contentTopic) {
      throw new Error("Missing content topic");
    }
    if (!bytes || !bytes.length) {
      throw new Error("Cannot publish empty message");
    }
  }
  /**
   * Low level method for publishing envelopes to the XMTP network with
   * no pre-processing or encryption applied.
   *
   * Primarily used internally
   *
   * @param envelopes PublishParams[]
   */
  async publishEnvelopes(envelopes) {
    for (const env of envelopes) {
      this.validateEnvelope(env);
    }
    await this.apiClient.publish(envelopes);
  }
  /**
   * Register a codec to be automatically used for encoding/decoding
   * messages of the given Content Type
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  registerCodec(codec) {
    const id = codec.contentType;
    const key = `${id.authorityId}/${id.typeId}`;
    this._codecs.set(key, codec);
  }
  /**
   * Find a matching codec for a given `ContentTypeId` from the
   * client's codec registry
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  codecFor(contentType) {
    const key = `${contentType.authorityId}/${contentType.typeId}`;
    const codec = this._codecs.get(key);
    if (!codec) {
      return void 0;
    }
    if (contentType.versionMajor > codec.contentType.versionMajor) {
      return void 0;
    }
    return codec;
  }
  /**
   * Convert arbitrary content into a serialized `EncodedContent` instance
   * with the given options
   */
  async encodeContent(content$1, options) {
    const contentType = options?.contentType || ContentTypeText;
    const codec = this.codecFor(contentType);
    if (!codec) {
      throw new Error("unknown content type " + contentType);
    }
    const encoded = codec.encode(content$1, this);
    if (options?.contentFallback) {
      encoded.fallback = options.contentFallback;
    }
    if (typeof options?.compression === "number") {
      encoded.compression = options.compression;
    }
    await compress(encoded);
    return content.EncodedContent.encode(encoded).finish();
  }
  listInvitations(opts) {
    return this.listEnvelopes(
      buildUserInviteTopic(this.address),
      async (env) => env,
      opts
    );
  }
  /**
   * List stored messages from the specified topic.
   *
   * A specified mapper function will be applied to each envelope.
   * If the mapper function throws an error during processing, the
   * envelope will be discarded.
   */
  async listEnvelopes(topic, mapper, opts) {
    if (!opts) {
      opts = {};
    }
    const { startTime, endTime, limit } = opts;
    const envelopes = await this.apiClient.query(
      { contentTopic: topic, startTime, endTime },
      {
        direction: opts.direction || messageApi.SortDirection.SORT_DIRECTION_ASCENDING,
        limit
      }
    );
    const results = [];
    for (const env of envelopes) {
      if (!env.message)
        continue;
      try {
        const res = await mapper(env);
        results.push(res);
      } catch (e) {
        console.warn("Error in listEnvelopes mapper", e);
      }
    }
    return results;
  }
  /**
   * List messages on a given set of content topics, yielding one page at a time
   */
  listEnvelopesPaginated(contentTopic, mapper, opts) {
    return mapPaginatedStream(
      this.apiClient.queryIteratePages(
        {
          contentTopic,
          startTime: opts?.startTime,
          endTime: opts?.endTime
        },
        { direction: opts?.direction, pageSize: opts?.pageSize || 100 }
      ),
      mapper
    );
  }
};
function createApiClientFromOptions(options) {
  const apiUrl = options.apiUrl || ApiUrls[options.env];
  return new ApiClient(apiUrl, { appVersion: options.appVersion });
}
async function getUserContactFromNetwork(apiClient, peerAddress) {
  const stream = apiClient.queryIterator(
    { contentTopic: buildUserContactTopic(peerAddress) },
    { pageSize: 5, direction: SortDirection.SORT_DIRECTION_DESCENDING }
  );
  for await (const env of stream) {
    if (!env.message)
      continue;
    const keyBundle = decodeContactBundle(b64Decode3(env.message.toString()));
    let address;
    try {
      address = await keyBundle?.walletSignatureAddress();
    } catch (e) {
      address = void 0;
    }
    if (address === peerAddress) {
      return keyBundle;
    }
  }
  return void 0;
}
async function getUserContactsFromNetwork(apiClient, peerAddresses) {
  const userContactTopics = peerAddresses.map(buildUserContactTopic);
  const topicToEnvelopes = await apiClient.batchQuery(
    userContactTopics.map((topic) => ({
      contentTopic: topic,
      pageSize: 5,
      direction: SortDirection.SORT_DIRECTION_DESCENDING
    }))
  );
  return Promise.all(
    peerAddresses.map(async (address, index) => {
      const envelopes = topicToEnvelopes[index];
      if (!envelopes) {
        return void 0;
      }
      for (const env of envelopes) {
        if (!env.message)
          continue;
        try {
          const keyBundle = decodeContactBundle(
            b64Decode3(env.message.toString())
          );
          const signingAddress = await keyBundle?.walletSignatureAddress();
          if (address === signingAddress) {
            return keyBundle;
          } else {
            console.info("Received contact bundle with incorrect address");
          }
        } catch (e) {
          console.info("Invalid contact bundle", e);
        }
      }
      return void 0;
    })
  );
}
function defaultKeystoreProviders() {
  return [
    // First check to see if a `privateKeyOverride` is provided and use that
    new StaticKeystoreProvider(),
    // Next check to see if a EncryptedPrivateKeyBundle exists on the network for the wallet
    new NetworkKeystoreProvider(),
    // If the first two failed with `KeystoreProviderUnavailableError`, then generate a new key and write it to the network
    new KeyGeneratorKeystoreProvider()
  ];
}
async function bootstrapKeystore(opts, apiClient, wallet) {
  for (const provider of opts.keystoreProviders) {
    try {
      return await provider.newKeystore(opts, apiClient, wallet ?? void 0);
    } catch (err) {
      if (err instanceof KeystoreProviderUnavailableError) {
        continue;
      }
      throw err;
    }
  }
  throw new Error("No keystore providers available");
}

// src/codecs/TypingNotification.ts
var ContentTypeTypingNotification = new ContentTypeId({
  authorityId: "xmtp.com",
  typeId: "typingNotification",
  versionMajor: 1,
  versionMinor: 0
});
var TypingNotificationCodec = class {
  get contentType() {
    return ContentTypeTypingNotification;
  }
  encode(content) {
    return {
      type: ContentTypeTypingNotification,
      parameters: {
        timestamp: content.timestamp.toISOString(),
        typerAddress: content.typerAddress,
        isFinished: content.isFinished ? "true" : "false"
      },
      content: new Uint8Array()
    };
  }
  decode(content) {
    const timestamp = new Date(content.parameters.timestamp);
    const typerAddress = content.parameters.senderAddress;
    const isFinished = content.parameters.isFinished === "true";
    return {
      timestamp,
      typerAddress,
      isFinished
    };
  }
};
var ContentTypeComposite = new ContentTypeId({
  authorityId: "xmtp.org",
  typeId: "composite",
  versionMajor: 1,
  versionMinor: 0
});
var CompositeCodec = class {
  get contentType() {
    return ContentTypeComposite;
  }
  encode(content, codecs) {
    const part = this.toProto(content, codecs);
    let composite$1;
    if (part.composite) {
      composite$1 = part.composite;
    } else {
      composite$1 = { parts: [part] };
    }
    const bytes = composite.Composite.encode(composite$1).finish();
    return {
      type: ContentTypeComposite,
      parameters: {},
      content: bytes
    };
  }
  decode(content, codecs) {
    return this.fromProto(
      { composite: composite.Composite.decode(content.content), part: void 0 },
      codecs
    );
  }
  toProto(content, codecs) {
    if ("type" in content) {
      const codec = codecs.codecFor(content.type);
      if (!codec) {
        throw new Error(`missing codec for part type ${content.type}`);
      }
      return {
        part: codec.encode(content.content, codecs),
        composite: void 0
      };
    }
    const parts = new Array();
    for (const part of content.parts) {
      parts.push(this.toProto(part, codecs));
    }
    return { composite: { parts }, part: void 0 };
  }
  fromProto(content, codecs) {
    if (content.part) {
      if (!content.part.type) {
        throw new Error("missing part content type");
      }
      const contentType = new ContentTypeId(content.part.type);
      const codec = codecs.codecFor(contentType);
      if (!codec) {
        throw new Error(`missing codec for part type ${contentType}`);
      }
      return {
        type: contentType,
        content: codec.decode(content.part, codecs)
      };
    }
    if (!content.composite) {
      throw new Error("invalid composite");
    }
    const parts = new Array();
    for (const part of content.composite.parts) {
      parts.push(this.fromProto(part, codecs));
    }
    return { parts };
  }
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/

export { ApiUrls, Ciphertext, Client, CompositeCodec, Compression, ContentTypeComposite, ContentTypeFallback, ContentTypeId, ContentTypeText, ContentTypeTypingNotification, Conversations, DecodedMessage, EncryptedPersistence, InMemoryKeystore, KeyGeneratorKeystoreProvider, LocalStoragePersistence, MessageV1, MessageV2, NetworkKeystoreProvider, PrefixedPersistence, PrivateKey, PublicKey, PublicKeyBundle, SealedInvitation, Signature, SignedPublicKey, SignedPublicKeyBundle, SortDirection, StaticKeystoreProvider, Stream, TextCodec, TypingNotificationCodec, buildContentTopic, buildDirectMessageTopic, buildDirectMessageTopicV2, buildUserContactTopic, buildUserIntroTopic, buildUserInviteTopic, buildUserPrivateStoreTopic, dateToNs, decodeContactBundle, decodeContent, decrypt, encrypt, fromNanoString, mapPaginatedStream, nsToDate, toNanoString };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map